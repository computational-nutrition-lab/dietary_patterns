# Need to have the variables (foods) in the columns, in order to filter for them.
food_t <- t(food)
head(food_t)
head(food_t,1)
dim(food_t)
dim(food)
food_t.hel <- decostand(food_t, method = "hellinger")
head(food,1)
# ---------------------------------------------------------------------------------------------------------------
# Hellinger transformation (to base ordination on presence similarity, not absence similarity)
# Need to have the variables (foods) in the columns, in order to filter for them.
min(food)
apply(food, 2, min)
min(apply(food, 2, min))
max(apply(food, 2, min))
# Look at the min values of each column. except for the last column which is taxonomy.
apply(food[, -129], 2, min)
# Look at the min values of each column. except for the last column which is taxonomy.
apply(food[, -129], 2, min)
dim(food_t)
colnames(food_t) <- NA
apply(food-t, 1, min)
apply(food_t, 1, min)
apply(food_t[-129, ], 1, min)
# ---------------------------------------------------------------------------------------------------------------
# Hellinger transformation (to base ordination on presence similarity, not absence similarity)
# Need to have the variables (foods) in the columns, in order to filter for them.
food_t <- t(food)
food_t.hel <- decostand(food_t, method = "hellinger")
head(spe)
head(food_t,1)
View(food)
head(spe)
# Hellinger transformation.
food_t.hel <- decostand(food_t, method = "hellinger")
food_t[1,1]
food_t[1:2,1:2]
df1 <âˆ’ lapply(food_t,as.numeric)
dim(df1)
dim(df1)
# ---------------------------------------------------------------------------------------------------------------
# Hellinger transformation (to base ordination on presence similarity, not absence similarity)
# Need to have the variables (foods) in the columns, in order to filter for them.
food_t <- as.data.frame(t(food))
df1 <- lapply(food_t, as.numeric)
dim(df1)
head(food_t, 1)
food_t[1:2, 1:2]
str(food_t)
# ---------------------------------------------------------------------------------------------------------------
# Hellinger transformation (to base ordination on presence similarity, not absence similarity)
# Need to have the variables (foods) in the columns, in order to filter for them.
food_t <- data.frame(t(food))
food_t[1:2, 1:2]
str(food_t)
is(food_t)
df1 <- lapply(food_t, as.numeric)
warnings()
food_t.hel <- decostand(food_t, method = "hellinger")
# ---------------------------------------------------------------------------------------------------------------
# Hellinger transformation (to base ordination on presence similarity, not absence similarity)
# Need to have the variables (foods) in the columns, in order to filter for them.
is(food)
is(food_t)
food.hel <- decostand(food, method = "hellinger")
head(food,1)
food.hel <- decostand(food[, -129], method = "hellinger")
head(food.hel,1)
head(food.hel,2)
head(food_t, 1)
# Pick up what I need
mea_1 <- mea[, c("SEQN", "BMDSTATS" )]
demog_1 <- demog[, c("SEQN", "INDHHIN2" )] # annual household income (just to see)
mea_demog_1 <- merge(mea_1, demog_1, by="SEQN")
food$SEQN
# Take only SEQN that are in food
colnames(food)
food_t[1:2, 1:2]
rownames(demog) <- paste("X", demog$SEQN, sep="") # Add 'X' at the beginning
# demog needs to have XSEQN as rownames in order to use it in PrepMeta function.
head(demog,1)
colnames(food)
# Take only the SEQN that are in food
head(food,1)
demog$XSEQN <-     paste("X", demog$SEQN, sep="") # Add 'X' at the beginning
# demog needs to have XSEQN as rownames in order to use it in PrepMeta function.
head(demog,1)
mea$XSEQN <-     paste("X", mea$SEQN, sep="") # Add 'X' at the beginning
head(mea, 1)
mea_demog_1 <- merge(mea_1, demog_1, by="XSEQN")
# Pick up what I need
mea_1 <- mea[, c("XSEQN", "BMDSTATS" )]
demog_1 <- demog[, c("XSEQN", "INDHHIN2" )] # annual household income (just to see)
mea_demog_1 <- merge(mea_1, demog_1, by="XSEQN")
head(mea_demog_1)
# Take only the XSEQN that are in food
head(food, 1)
mea_demog_1_s <- mea_demog_1[mea_demog_1$XSEQN %in% colnames(food) ]
mea_demog_1_s <- mea_demog_1[mea_demog_1$XSEQN %in% colnames(food), ]
head(mea_demog_1_s)
dim(mea_demog_1_s)
dim(mea_demog_1)
# This is my "env" matrix....
env <- mea_demog_1_s
# ---------------------------------------------------------------------------------------------------------------
# Scale and center variables
env.z <- decostand(env, method = "standardize")
head(env)
row.names(env) <- env$XSEQN
row.names(env)
env <- env[-1, ]
head(env)
# This is my "env" matrix....
env <- mea_demog_1_s
head(env)
row.names(env) <- env$XSEQN
env <- env[, -1]
head(env)
env.z <- decostand(env, method = "standardize")
library(naninar)
library(naniar)
vis_miss(env)
env.z <- decostand(env, method = "standardize", na.rm = T)
head(env.z)
# Variables are now centered around a mean of 0
round(apply(env.z, 2, mean), 1)
# Variables are now centered around a mean of 0
round(apply(env.z, 2, mean), 1)
# and scaled to have a standard deviation of 1
apply(env.z, 2, sd)
spe.hel
# ---------------------------------------------------------------------------------------------------------------
# RDA
# Run the RDA.
# Model the effect of the body measure and demographic variables on dietary patterns.
head(food)
food.rda <- rda(food_t ~ ., data = env.z)
# This is my "env" matrix....
env_1 <- mea_demog_1_s
head(env_1)
row.names(env_1) <- env_1$XSEQN
env_2 <- env_1[, -1]
vis_miss(env_2)
# Need to remove those with missing data... uuugh
env_3 <- na.omit(env_2)
vis_miss(env_3)
vis_miss(env_1)
# Need to remove those with missing data... uuugh
env_2 <- na.omit(env_1)
vis_miss(env_2)
colnames(food)
row.names(food_t)
food.rda <- rda(food_t ~ ., data = env.z, na.rm=T)
viz_miss(food)
vis_miss(food)
#
food_t$XSEQN <- row.names(food_t)
# Need to remove those with missing metadata... uuugh
env_2 <- na.omit(env_1)
vis_miss(env_2)
colnames(env_2)
food_t_s <- food_t[food_t$XSEQN %in% env_2$XSEQN, ]
vis_miss(food_t_s)
head(env_2)
row.names(env_2) <- env_1$XSEQN
row.names(env_2) <- env_2$XSEQN
head(env_2)
env_3 <- env_2[, -1]
env.z <- decostand(env_3, method = "standardize")
head(env.z)
# Variables are now centered around a mean of 0
round(apply(env.z, 2, mean), 1)
# and scaled to have a standard deviation of 1
apply(env.z, 2, sd)
food.rda <- rda(food_t ~ ., data = env.z, na.rm=T)
food.rda <- rda(food_t ~ ., data = env.z)
# ---------------------------------------------------------------------------------------------------------------
# RDA
# Run the RDA.
# Model the effect of the body measure and demographic variables on dietary patterns.
head(food_t_s)
food_t_s[1:2, 1:2]
food_t_s[1:2, 1191:1192]
food.rda <- rda(food_t_s ~ ., data = env.z)
# Need to remove the XSEQN column.
food_t_s_2 <- food_t_s[, -1192]
food.rda <- rda(food_t_s_2 ~ ., data = env.z)
food_t_s_2[1:2, 1190:1191]
str(food_t_s_2)
# convert characters to numeric.
sapply( food_t_s_2, as.numeric )
# convert characters to numeric.
food_t_s_3 <-  sapply( food_t_s_2, as.numeric )
str(food_t_s_3)
# RDA
food.rda <- rda(food_t_s_3 ~ ., data = env.z)
summary(spe.rdafood.rda)
summary(food.rda)
# Forward selection of variables:
fwd.sel <- ordiR2step(rda(food_t_s_3 ~ 1, data = env.z), # lower model limit (simple!)
scope = formula(food.rda), # upper model limit (the "full" model)
direction = "forward",
R2scope = TRUE, # can't surpass the "full" model's R2
pstep = 1000,
trace = TRUE) # change to TRUE to see the selection process!
# Check the new model with forward-selected variables
fwd.sel$call
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
spe.rda.signif <- rda(spe.hel ~ 1, data = env.z)
# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(spe.rda.signif)
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
spe.rda.signif <- rda(spe.hel ~ ., data = env.z)
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
food_t_s_3.rda.signif <- rda(food_t_s_3 ~ 1, data = env.z)
# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(food_t_s_3.rda.signif)
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
food_t_s_3.rda.signif <- rda(food_t_s_3 ~ 1, data = env.z)
food_t_s_3.rda.signif
anova.cca(food_t_s_3.rda.signif, step = 1000)
anova.cca(food_t_s_3.rda.signif, step = 1000, by = "term")
demog <- read.xport("GLU_I.XPT")
demog <- read.xport("../DEMO_I.XPT")
glu <- read.xport("GLU_I.XPT")
head(glu,1)
glu$XSEQN <-     paste("X", mea$SEQN, sep="") # Add 'X' at the beginning
glu$XSEQN <-     paste("X", glu$SEQN, sep="") # Add 'X' at the beginning
head(glu, 1)
# demog_1 <- glu[, c("XSEQN", "INDHHIN2" )] # annual household income (just to see)
glu_1 <- glu[, c("XSEQN", "LBXGLU" )]   # fasting glucose (mg/dL)
# demog_1 <- glu[, c("XSEQN", "INDHHIN2" )] # annual household income (just to see)
demog_1 <- glu[, c("XSEQN", "LBXGLU" )]   # fasting glucose (mg/dL)
mea_demog_1 <- merge(mea_1, demog_1, by="XSEQN")
# Pick up what I need
mea_1 <- mea[, c("XSEQN", "BMXBMI", "BMXWAIST" , 'BMDAVSAD')]
# demog_1 <- glu[, c("XSEQN", "INDHHIN2" )] # annual household income (just to see)
demog_1 <- glu[, c("XSEQN", "LBXGLU" )]   # fasting glucose (mg/dL)
mea_demog_1 <- merge(mea_1, demog_1, by="XSEQN")
head(mea_demog_1)
dim(mea_demog_1)
# Pick up what I need
mea_1 <- mea[, c("XSEQN", "BMXBMI", "BMXWAIST" , 'BMDAVSAD')]
# demog_1 <- glu[, c("XSEQN", "INDHHIN2" )] # annual household income (just to see)
demog_1 <- glu[, c("XSEQN", "LBXGLU" )]   # fasting glucose (mg/dL)
mea_demog_1 <- merge(mea_1, demog_1, by="XSEQN")
head(mea_demog_1)
dim(mea_demog_1)
# Take only the XSEQN that are in food
head(food, 1)
mea_demog_1_s <- mea_demog_1[mea_demog_1$XSEQN %in% colnames(food), ]
head(mea_demog_1_s)
dim(mea_demog_1_s)
# This is my "env" matrix....
env_1 <- mea_demog_1_s
# Need to remove any missing data in order to run RDA. really??
library(naniar)
vis_miss(env_1)
# Need to remove any missing data in order to run RDA. really??
library(naniar)
vis_miss(env_1)
# Need to remove those with missing metadata... uuugh
env_2 <- na.omit(env_1)
vis_miss(env_2)
# Add a column that has the XSEQN.
food_t$XSEQN <- row.names(food_t)
# From "food_t", Pick up only the SEQN in env_2.
food_t_s <- food_t[food_t$XSEQN %in% env_2$XSEQN, ]
# ---------------------------------------------------------------------------------------------------------------
# RDA
# Run the RDA.
# Model the effect of the body measure and demographic variables on dietary patterns.
head(food_t_s)
food_t_s[1:2, 1191:1192]
# Need to remove the XSEQN column.
food_t_s_2 <- food_t_s[, -1192]
food_t_s_2[1:2, 1190:1191]
str(food_t_s_2)
# convert characters to numeric.
food_t_s_3 <-  sapply( food_t_s_2, as.numeric )
str(food_t_s_3)
env.z
# Make XSEQN as the rownames and delete that column.
head(env_2)
row.names(env_2) <- env_2$XSEQN
env_3 <- env_2[, -1]
env.z <- decostand(env_3, method = "standardize")
head(env.z)
# Variables are now centered around a mean of 0
round(apply(env.z, 2, mean), 1)
# and scaled to have a standard deviation of 1
apply(env.z, 2, sd)
str(food_t_s_3)
# RDA
food.rda <- rda(food_t_s_3 ~ ., data = env.z)
summary(food.rda)
# Forward selection of variables:
fwd.sel <- ordiR2step(rda(food_t_s_3 ~ 1, data = env.z), # lower model limit (simple!)
scope = formula(food.rda), # upper model limit (the "full" model)
direction = "forward",
R2scope = TRUE, # can't surpass the "full" model's R2
pstep = 1000,
trace = TRUE) # change to TRUE to see the selection process!
# Check the new model with forward-selected variables
fwd.sel$call
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
food_t_s_3.rda.signif <- rda(food_t_s_3 ~ 1, data = env.z)
# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(food_t_s_3.rda.signif)
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
food_t_s_3.rda.signif <- rda(food_t_s_3 ~ ., data = env.z)
# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(food_t_s_3.rda.signif)
# Forward selection of variables:
fwd.sel <- ordiR2step(rda(food_t_s_3 ~ 1, data = env.z), # lower model limit (simple!)
scope = formula(food.rda), # upper model limit (the "full" model)
direction = "forward",
R2scope = TRUE, # can't surpass the "full" model's R2
pstep = 1000,
trace = FALSE) # change to TRUE to see the selection process!
# Check the new model with forward-selected variables
fwd.sel$call
# RDA
food.rda <- rda(food_t_s_3 ~ ., data = env.z)
summary(food.rda)
View(food.rda)
setwd("~/GitHub/dietary_patterns/RDA/")
# Species community data frame (fish abundance)
# spe <- read.csv("data/doubsspe.csv", row.names = 1)
spe_raw <- read.table("data/doubsspe.txt", sep=",", header=T, row.names = 1)
spe <- spe_raw[-8, ]  # Site number 8 contains no species, so we remove row 8 (site 8)
head(spe)
# Environmental data frame: "DoubsEnv.csv"
# env <- read.csv("data/doubsenv.csv", row.names = 1)
env_raw <- read.table("data/doubsenv.txt", sep=",", header=T, row.names = 1)
head(env_raw)
env <- env_raw[-8, ]  # Remove corresponding abiotic data for site 8 (because removed from fish data).
head(env)
# Count number of species frequencies in each abundance class
ab <- table(unlist(spe))
# Plot distribution of species frequencies
barplot(ab, las = 1, # make axis labels perpendicular to axis
xlab = "Abundance class", ylab = "Frequency", # label axes
col = grey(5:0/5)) # 5-colour gradient for the bars
# Count the number of zeros in the dataset
sum(spe == 0)
# Calculate proportion of zeros in the dataset
sum(spe == 0)/(nrow(spe) * ncol(spe))
# Apply Hellinger transformation to correct for the double zero problem
spe.hel <- decostand(spe, method = "hellinger")
# We can visually look for correlations between variables:
heatmap(abs(cor(env)),
# Compute pearson correlation (note they are absolute values)
col = rev(heat.colors(6)),
Colv = NA, Rowv = NA)
legend("topright",
title = "Absolute Pearson R",
legend =  round(seq(0,1, length.out = 6),1),
y.intersp = 0.7, bty = "n",
fill = rev(heat.colors(6)))
# Scale and center variables
env.z <- decostand(env, method = "standardize")
head(env.z)
# Variables are now centered around a mean of 0
round(apply(env.z, 2, mean), 1)
# and scaled to have a standard deviation of 1
apply(env.z, 2, sd)
# We'll use our standardized environmental data, but we
# will remove 'das', which was correlated with many other
# variables:
env.z <- subset(env.z, select = -das)
head(env.z)
# Run the RDA.
# Model the effect of all environmental variables on fish
# community composition
spe.rda <- rda(spe.hel ~ ., data = env.z)
summary(spe.rda)
summary(spe.rda)[1]
summary(spe.rda)[2]
summary(spe.rda)[3]
summary(spe.rda)[10]
aaa <- summary(spe.rda)
head(aaa)
View(aaa)
summary(spe.rda)[15]
summary(spe.rda)[14]
summary(spe.rda)[13]
summary(spe.rda)[11]
summary(spe.rda)[12]
summary(spe.rda)[9]
summary(spe.rda)[8]
summary(spe.rda)[7]
summary(spe.rda)[6]
summary(spe.rda)[5]
summary(spe.rda)[4]
summary(spe.rda)[3]
spe.rda
RsquareAdj(spe.rda)
RsquareAdjR(food.rda)
RsquareAdj(food.rda)
# RDA
food.rda <- rda(food_t_s_3 ~ ., data = env.z)
mea <- read.xport("../BodyMeasures/BMX_I.XPT")
demog <- read.xport("../DEMO_I.XPT")
glu <- read.xport("GLU_I.XPT")
head(mea,1)
head(demog,1)
head(glu,1)
colnames(food)  # SEQN starts with 'X'
# demog needs to have XSEQN as rownames in order to use it in PrepMeta function.
rownames(demog) <- paste("X", demog$SEQN, sep="") # Add 'X' at the beginning
demog$XSEQN <-     paste("X", demog$SEQN, sep="") # Add 'X' at the beginning
head(demog, 1)
mea$XSEQN <-     paste("X", mea$SEQN, sep="") # Add 'X' at the beginning
head(mea, 1)
glu$XSEQN <-     paste("X", glu$SEQN, sep="") # Add 'X' at the beginning
head(glu, 1)
# Pick up what I need
mea_1 <- mea[, c("XSEQN", "BMXBMI", "BMXWAIST" , 'BMDAVSAD')]
# demog_1 <- glu[, c("XSEQN", "INDHHIN2" )] # annual household income (just to see)
demog_1 <- glu[, c("XSEQN", "LBXGLU" )]   # fasting glucose (mg/dL)
mea_demog_1 <- merge(mea_1, demog_1, by="XSEQN")
head(mea_demog_1)
dim(mea_demog_1)
# Take only the XSEQN that are in food
head(food, 1)
mea_demog_1_s <- mea_demog_1[mea_demog_1$XSEQN %in% colnames(food), ]
head(mea_demog_1_s)
dim(mea_demog_1_s)
# This is my "env" matrix....
env_1 <- mea_demog_1_s
# Need to remove any missing data in order to run RDA. really??
library(naniar)
vis_miss(env_1)
# Need to remove those with missing metadata... uuugh
env_2 <- na.omit(env_1)
vis_miss(env_2)
# Add a column that has the XSEQN.
food_t$XSEQN <- row.names(food_t)
# From "food_t", Pick up only the SEQN in env_2.
food_t_s <- food_t[food_t$XSEQN %in% env_2$XSEQN, ]
# This is my food (response matrix)
# ---------------------------------------------------------------------------------------------------------------
# Scale and center variables
# Make XSEQN as the rownames and delete that column.
head(env_2)
row.names(env_2) <- env_2$XSEQN
env_3 <- env_2[, -1]
env.z <- decostand(env_3, method = "standardize")
head(env.z)
# Variables are now centered around a mean of 0
round(apply(env.z, 2, mean), 1)
# and scaled to have a standard deviation of 1
apply(env.z, 2, sd)
# ---------------------------------------------------------------------------------------------------------------
# RDA
# Run the RDA.
# Model the effect of the body measure and demographic variables on dietary patterns.
head(food_t_s)
food_t_s[1:2, 1191:1192]
# Need to remove the XSEQN column.
food_t_s_2 <- food_t_s[, -1192]
food_t_s_2[1:2, 1190:1191]
str(food_t_s_2)
# convert characters to numeric.
food_t_s_3 <-  sapply( food_t_s_2, as.numeric )
str(food_t_s_3)
# RDA
food.rda <- rda(food_t_s_3 ~ ., data = env.z)
summary(food.rda)
RsquareAdj(food.rda)
RsquareAdj(food.rda)
summary(food.rda)
RsquareAdj(food.rda)
# Forward selection of variables:
fwd.sel <- ordiR2step(rda(food_t_s_3 ~ 1, data = env.z), # lower model limit (simple!)
scope = formula(food.rda), # upper model limit (the "full" model)
direction = "forward",
R2scope = TRUE, # can't surpass the "full" model's R2
pstep = 1000,
trace = FALSE) # change to TRUE to see the selection process!
# Check the new model with forward-selected variables
fwd.sel$call
# What is the adjusted R2 of the RDA with the selected variables?
# Write our new model
food_t_s_3.rda.signif <- rda(food_t_s_3 ~ 1, data = env.z)
# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(food_t_s_3.rda.signif)
anova.cca(food_t_s_3.rda.signif, step = 1000)
# But adjusted R square is -0.002882421.
anova.cca(food.rda, step = 1000)
RsquareAdj(food.rda)
# Forward selection of variables:
fwd.sel <- ordiR2step(rda(food_t_s_3 ~ 1, data = env.z), # lower model limit (simple!)
scope = formula(food.rda), # upper model limit (the "full" model)
direction = "forward",
R2scope = TRUE, # can't surpass the "full" model's R2
pstep = 1000,
trace = FALSE) # change to TRUE to see the selection process!
# Check the new model with forward-selected variables
fwd.sel$call
