tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match
print(identical(dim(tabA), dim(tabB)))
print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
out_df <- cbind(foodcode_grams_df, out)
paste0("Check if the food code in original input matches those in output - ",
identical(out_df$Food_code, input.food[, "Food_code"]),
sep="")
# Exclude the first 2 columns.
dropcol = c("Food_code", grams)
result_1 <- out_df[, !(names(out_df) %in% dropcol)]
# aaa= as.numeric(out_df$Food_code) - as.numeric(Food_D1$Food_code)
# table(aaa)
# identical(as.numeric(out_df$DR1IGRMS), as.numeric(Food_D1$DR1IGRMS))
# Join Food_Dx and result_v.
Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Let's try the function!
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/FPED/Food_D1_FC_byfun.txt")
# Matrix Mutiplication functions.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- Food_D1[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match
print(identical(dim(tabA), dim(tabB)))
print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
out_df <- cbind(foodcode_grams_df, out)
print("Check if the food code in original input matches those in output - ",
identical(out_df$Food_code, input.food[, "Food_code"]),
sep="")
Food_D1_FC <- out_df
# # Exclude the first 2 columns.
# dropcol = c("Food_code", grams)
# result_1 <- out_df[, !(names(out_df) %in% dropcol)]
#
# # aaa= as.numeric(out_df$Food_code) - as.numeric(Food_D1$Food_code)
# # table(aaa)
# # identical(as.numeric(out_df$DR1IGRMS), as.numeric(Food_D1$DR1IGRMS))
#
# # Join Food_Dx and result_v.
# Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Let's try the function!
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/FPED/Food_D1_FC_byfun_out_df.txt")
# Matrix Mutiplication functions.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- Food_D1[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match
print(identical(dim(tabA), dim(tabB)))
print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
out_df <- cbind(foodcode_grams_df, out)
print(identical(out_df$Food_code, input.food[, "Food_code"]))
print("Check if the food code in original input matches those in output - ",
identical(out_df$Food_code, input.food[, "Food_code"]),
sep="")
Food_D1_FC <- out_df
# # Exclude the first 2 columns.
# dropcol = c("Food_code", grams)
# result_1 <- out_df[, !(names(out_df) %in% dropcol)]
#
# # aaa= as.numeric(out_df$Food_code) - as.numeric(Food_D1$Food_code)
# # table(aaa)
# # identical(as.numeric(out_df$DR1IGRMS), as.numeric(Food_D1$DR1IGRMS))
#
# # Join Food_Dx and result_v.
# Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Let's try the function!
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/FPED/Food_D1_FC_byfun_out_df.txt")
# Matrix Mutiplication functions.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- Food_D1[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match
print(identical(dim(tabA), dim(tabB)))
print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
out_df <- cbind(foodcode_grams_df, out)
print(identical(out_df$Food_code, input.food[, "Food_code"]))
print(head(out_df$Food_code), 10)
print(head(input.food[, "Food_code"]), 10)
print("Check if the food code in original input matches those in output - ",
identical(out_df$Food_code, input.food[, "Food_code"]),
sep="")
Food_D1_FC <- out_df
# # Exclude the first 2 columns.
# dropcol = c("Food_code", grams)
# result_1 <- out_df[, !(names(out_df) %in% dropcol)]
#
# # aaa= as.numeric(out_df$Food_code) - as.numeric(Food_D1$Food_code)
# # table(aaa)
# # identical(as.numeric(out_df$DR1IGRMS), as.numeric(Food_D1$DR1IGRMS))
#
# # Join Food_Dx and result_v.
# Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Let's try the function! #### WILL TAKE A FEW MOMENTS.
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/FPED/Food_D1_FC_byfun_out_df.txt")
# Matrix Mutiplication functions.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- Food_D1[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match
print(identical(dim(tabA), dim(tabB)))
print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
out_df <- cbind(foodcode_grams_df, out)
print(identical(out_df$Food_code, input.food[, "Food_code"]))
print(head(out_df$Food_code), 10)
print(head(input.food[, "Food_code"]), 10)
print("Check if the food code in original input matches those in output - ",
identical(out_df$Food_code, input.food[, "Food_code"]),
sep="")
# Food_D1_FC <- out_df
# Exclude the first 2 columns.
dropcol = c("Food_code", grams)
print(dropcol)
result_1 <- out_df[, !(names(out_df) %in% dropcol)]
# aaa= as.numeric(out_df$Food_code) - as.numeric(Food_D1$Food_code)
# table(aaa)
# identical(as.numeric(out_df$DR1IGRMS), as.numeric(Food_D1$DR1IGRMS))
# Join Food_Dx and result_v.
Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Let's try the function! #### WILL TAKE A FEW MOMENTS.
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/FPED/Food_D1_FC_byfun_2.txt")
# Matrix Mutiplication functions.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- Food_D1[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match - un-commnt if editing.
# print(identical(dim(tabA), dim(tabB)))
# print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
# print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
# Join
out_df <- cbind(foodcode_grams_df, out)
# Exclude the first 2 columns.
dropcol = c("Food_code", grams)
print(dropcol)
result_1 <- out_df[, !(names(out_df) %in% dropcol)]
# Join Food_Dx and result_v.
Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Let's try the function! #### WILL TAKE A FEW MOMENTS. ####
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/FPED/Food_D1_FC_byfun_3.txt")
bufun <- read.table("eg_data/NHANES/FPED/Food_D1_FC_byfun.txt", sep="\t", header=T)
rm(bufun)
byfun <- read.table("eg_data/NHANES/FPED/Food_D1_FC_byfun.txt", sep="\t", header=T)
byfun2 <- read.table("eg_data/NHANES/FPED/Food_D1_FC_byfun2.txt", sep="\t", header=T)
byfun2 <- read.table("eg_data/NHANES/FPED/Food_D1_FC_byfun_2.txt", sep="\t", header=T)
byfun3 <- read.table("eg_data/NHANES/FPED/Food_D1_FC_byfun_3.txt", sep="\t", header=T)
dim(byfun)
dim(byfun2)
dim(byfun3)
identical(byfun$Food_code, byfun2$Food_code)
identical(byfun2$Food_code, byfun3$Food_code)
byfun$count_na <- rowSums(is.na(byfun))
byfun2$count_na <- rowSums(is.na(byfun2))
byfun3$count_na <- rowSums(is.na(byfun3))
table(byfun$count_na)
table(byfun2$count_na)
table(byfun3$count_na)
identical(byfun$DR1IGRMS, byfun2$DR1IGRMS)
identical(byfun2$DR1IGRMS, byfun3$DR1IGRMS)
# Matrix Mutiplication function to add food category and multiply the weight and serving for each row.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- Food_D1[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match - un-commnt if editing.
# print(identical(dim(tabA), dim(tabB)))
# print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
# print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
# Join
out_df <- cbind(foodcode_grams_df, out)
# Exclude the first 2 columns.
dropcol = c("Food_code", grams)
result_1 <- out_df[, !(names(out_df) %in% dropcol)]
# Join Food_Dx and result_v.
Food_D1_FC = cbind(Food_D1, result_1)
# Save as a txt file.
write.table(Food_D1_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Load the saved food items file.
Food_D1 <- read.table("eg_data/NHANES/Interview_IndFoods_Day1_DR1IFF_I_d.txt", sep="\t", header=T)
# Add the food items info and serving for each item. #### WILL TAKE A FEW MOMENTS. ####
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/Food_D1_FC.txt")
# Add food item description and save it as a txt file.
Food_D2 <- read.table("eg_data/NHANES/Interview_IndFoods_Day2_DR2IFF_I_d.txt", sep="\t", header=T)
# Load the saved food items file.
Food_D1 <- read.table("eg_data/NHANES/Interview_IndFoods_Day1_DR1IFF_I_d.txt", sep="\t", header=T)
# Day 2. Add the food items info and serving for each item. #### WILL TAKE A FEW MOMENTS. ####
AddFoodCat(input.food= Food_D2,
fped= FPED,
grams= "DR2IGRMS",
out.fn= "eg_data/NHANES/Food_D2_FC.txt")
# Matrix Mutiplication function to add food category and multiply the weight and serving for each row.
AddFoodCat <- function(input.food, fped, grams="DR1IGRMS", out.fn){
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- input.food[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match - un-commnt if editing.
# print(identical(dim(tabA), dim(tabB)))
# print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
# print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
# Join
out_df <- cbind(foodcode_grams_df, out)
# Exclude the first 2 columns.
dropcol = c("Food_code", grams)
result_1 <- out_df[, !(names(out_df) %in% dropcol)]
# Join Food_Dx and result_v.
Food_DX_FC = cbind(input.food, result_1)
# Save as a txt file.
write.table(Food_DX_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Day 2. Add the food items info and serving for each item. #### WILL TAKE A FEW MOMENTS. ####
AddFoodCat(input.food= Food_D2,
fped= FPED,
grams= "DR2IGRMS",
out.fn= "eg_data/NHANES/Food_D2_FC.txt")
# Matrix Mutiplication function to add food category and multiply the weight and serving for each row.
AddFoodCat <- function(input.food, fped, grams, out.fn){     # grams are "DR1IGRMS" or "DR2IGRMS" etc..
# Pick up only the foodcode and grams.
columnstopick <- c("Food_code", grams)
FPED <- fped
Fdcd_GRMS <- input.food[, columnstopick]
n_food_cat <- length(colnames(FPED))-1  # Define the number of food categories.
# Create temporary dataframes for procesing.
dfA <- Fdcd_GRMS                                      # keep all because all match in FPED
dfB <- FPED[FPED$Food_code %in% Fdcd_GRMS$Food_code,] # keep only the matching codes
# rearrange dataframes to match on food_code
dfA2 <- cbind(dfA, rep(dfA[2], n_food_cat-1))         # repeat the DR2IGRMS values in table A
tabA <- as.matrix(dfA2[, -1])                           # convert to matrix, leave out food code
rownames(tabA) <- paste0(dfA2$Food_code, '_', dfA2[,2])  # rownames will be FOODCODE_GRAMS.
colnames(tabA) <- colnames(dfB)[2:(n_food_cat+1)]        # colnames will be food category names.
dfB2 <- dfB[match(dfA$Food_code, dfB$Food_code),]      # match table B to table A
tabB <- as.matrix(dfB2[,-1])                           # convert to matrix, leave out food code
rownames(tabB) <- dfB2$Food_code
# safety check: food codes match - un-commnt if editing.
# print(identical(dim(tabA), dim(tabB)))
# print(identical(gsub("_.*", "", rownames(tabA)), rownames(tabB)))
# print(identical(colnames(tabA), colnames(tabB)))
# Then we can perform matrix multiplication (element-wise)
#   I thought this would be advantageous as you just want to multiply one value
#   by a matching row in another table
out <- tabA * tabB/100
# reformatting to get a clean table
foodcode_grams_df <- data.frame(Food_code = gsub("_.*", "", rownames(out)),
GRMS = as.numeric(gsub(".*_","", rownames(out))))  # use a temporary column name
# Change the temporary columnname "GRMS" to the specified 'grams' argument.
colnames(foodcode_grams_df)[2] <- paste(grams)
# Convert to a df.
out <- data.frame(out)
# Number the rows.
rownames(out) <- 1:nrow(out)
# Join
out_df <- cbind(foodcode_grams_df, out)
# Exclude the first 2 columns.
dropcol = c("Food_code", grams)
result_1 <- out_df[, !(names(out_df) %in% dropcol)]
# Join Food_Dx and result_v.
Food_DX_FC = cbind(input.food, result_1)
# Save as a txt file.
write.table(Food_DX_FC, out.fn, sep="\t", row.names=F, quote=F)
}
# Add the food items info and serving for each item. #### WILL TAKE A FEW MOMENTS. ####
AddFoodCat(input.food= Food_D1,
fped= FPED,
grams= "DR1IGRMS",
out.fn= "eg_data/NHANES/Food_D1_FC.txt")
