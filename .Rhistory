var_to_use2 <- names(food2bb) %in% day2variables$V1
food2c <- food2bb[, var_to_use2]
colnames(food2c) <- gsub(colnames(food2c), pattern = "^DR2I", replacement = "")
colnames(food2c) <- gsub(colnames(food2c), pattern = "^DR2", replacement = "")
head(food2c, 1)
var_to_use2
day2variables$V1
# Copy to avoid overwriting
food1bb <- food1b
food2bb <- food2b
names(food1bb)
# Change "FoodAmt" back to "DR1GRMS" to be consistent with the variable names in dayXvariables
names(food1bb)[names(food1bb) == "FoodAmt"] <- "DR1IGRMS"
names(food2bb)[names(food2bb) == "FoodAmt"] <- "DR2IGRMS"
# Combine day 1 and day 2 data.
# Day 1
# Import the list of variables to be picked up in Day 1.
# day1variables <- read.table('eg_data/NHANES/NHANES_Food_VarNames_Day1.txt', header=F)  # OLD, before adding food category data.
day1variables <- read.table('eg_data/NHANES/NHANES_Food_VarNames_FC_Day1.txt', header=F)
tail(day1variables)
# Which variables to pick up from the food data
var_to_use1 <- names(food1bb) %in% day1variables$V1
# pick up only the specified variables
food1c <- food1bb[, var_to_use1]
# Remove "DR1T", "DR1" from the column names
colnames(food1c) <- gsub(colnames(food1c), pattern = "^DR1I", replacement = "")
colnames(food1c) <- gsub(colnames(food1c), pattern = "^DR1",  replacement = "")
# Check
head(food1c, 1)
# Do the same for Day 2
# day2variables <- read.table('eg_data/NHANES/NHANES_Food_VarNames_Day2.txt', header=F) # OLD, before adding food category data.
day2variables <- read.table('eg_data/NHANES/NHANES_Food_VarNames_FC_Day2.txt', header=F)
var_to_use2 <- names(food2bb) %in% day2variables$V1
food2c <- food2bb[, var_to_use2]
colnames(food2c) <- gsub(colnames(food2c), pattern = "^DR2I", replacement = "")
colnames(food2c) <- gsub(colnames(food2c), pattern = "^DR2", replacement = "")
head(food2c, 1)
# Make a day variable before combining
food1c$Day <- 1
food2c$Day <- 2
# Ensure the columns of food1c and food2c match before joining them.
identical(colnames(food1c), colnames(food2c))
# Combine food1 and food2 as a longtable.
food12c <- rbind(food1c, food2c)
# Pick up only the individuals listed in keepnames12.
food12d <- food12c[food12c$SEQN %in% keepnames12, ]
colnames(total12d)
# Load the calculated totals.
total12d <- read.table("eg_data/NHANES/NHANES1516_total_d12_FC.txt", sep="\t", header=T)
# Merge
total12c <- rbind(total1b, total2b)
# Save the calculated totals of day 1 and 2 as a txt file.
write.table(total12c, "eg_data/NHANES/NHANES1516_total_d12_FC.txt", sep="\t", row.names=F, quote=F)
# Calculate total for day 1. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Take only the Day 1 data
food12d_d1 <- subset(food12d, Day==1)
colnames(food12d_d1)
head(food12d)
# Calculate total for day 1. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Take only the Day 1 data
food12d_d1 <- subset(food12d, Day==1)
colnames(food12d_d1)
# Sum nutrients and food categories; this will be total data calculated by hand.
# First, speicify the first and the last column (variable) names to calculate totals for.
first.val <- "GRMS"
last.val <- "A_DRINKS"
start_col_num <- match(first.val, names(food12d_d1))  # The number of column that matches the first variable specified.
end_col_num <-   match(last.val, names(food12d_d1)) # The number of column that matches the last variable specified.
# Sum food items by SEQN from start through end columns.
total1 <- aggregate(food12d_d1[, start_col_num:end_col_num],
by=list(food12d_d1$SEQN),
FUN=sum)
total1$Day <- 1
colnames(total1)[1] <- "SEQN"
# Create a vector of number of food items reported by each participant.
n_items1 <- as.data.frame(table(food12d_d1$SEQN))
n_items1
colnames(n_items1) <- c("SEQN", "NoOfItems")
# Add it to total1
total1b <- merge(x=total1, y=n_items1, by="SEQN", all.x=T)
# Some checking
subset(total1b, NoOfItems<2) # should be zero.
# Look for any missing data
total1b[is.na(total1b$NoOfItems), ]
# Calculate total for day 2. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
food12d_d2 <- subset(food12d, Day==2)
# Sum nutrients.
# First, speicfy the first and the last column (variable) names to calculate totals for.
first.val <- "GRMS"
last.val <- "A_DRINKS"
start_col_num <- match(first.val, names(food12d_d2))  # The number of column that matches the first variable specified.
end_col_num <-   match(last.val, names(food12d_d2)) # The number of column that matches the last variable specified.
# Sum food items by SEQN from start through end columns.
total2 <- aggregate(food12d_d2[, start_col_num:end_col_num],
by=list(food12d_d2$SEQN),
FUN=sum)
total2$Day <- 2
colnames(total2)[1] <- "SEQN"
# Create a vector of number of food items reported by each participant.
n_items2 <- as.data.frame(table(food12d_d2$SEQN))
colnames(n_items2) <- c("SEQN", "NoOfItems")
# Add it to total1
total2b <- merge(x=total2, y=n_items2, by="SEQN", all.x=T)
# Some checking
subset(total2b, NoOfItems<2) # should be zero.
# Look for any missing data
total2b[is.na(total2b$NoOfItems), ]
# Merge totals day 1 and day 2
# Check if all the columnnames match.
identical(colnames(total1b), colnames(total2b))
# Merge
total12c <- rbind(total1b, total2b)
# Save the calculated totals of day 1 and 2 as a txt file.
write.table(total12c, "eg_data/NHANES/NHANES1516_total_d12_FC.txt", sep="\t", row.names=F, quote=F)
# Load the calculated totals.
total12d <- read.table("eg_data/NHANES/NHANES1516_total_d12_FC.txt", sep="\t", header=T)
# Take average of Day 1 and Day 2.
# First, specify the first and the last column (variable) names to calculate means for.
first.val <- "GRMS"
start_col_num <- match(first.val, names(total12d))  # The number of column that matches the first variable specified.
end_col_num <-   match(last.val,  names(total12d)) # The number of column that matches the last variable specified.
# Sum food items by SEQN from start through end columns.
meantotal12a <- aggregate(total12d[, start_col_num:end_col_num],
by=list(total12d$SEQN),
FUN=mean)
# Remove the day, which is now all 1.5 (the average of 1 and 2.)
meantotal12 <- meantotal12a[, !names(meantotal12a) %in% "Day"]
# Change "Group.1" to "SEQN".
colnames(meantotal12)[1] <- "SEQN"
# Remove the day, which is now all 1.5 (the average of 1 and 2.)
meantotal12 <- meantotal12a[, !names(meantotal12a) %in% "Day"]
# Change "Group.1" to "SEQN".
colnames(meantotal12)[1] <- "SEQN"
meantotal12
# Set where the NHANES data and food code table are.
# it is not in the eg_data folder because it's too large to save in GitHub folder.
# setwd("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16")
setwd("~/GitHub/dietary_patterns")
# Load necessary functions.
source("lib/load_clean_NHANES.R")
source("lib/prep_data_for_clustering.R")
meantotal12
# Save meantotals as a txt file.
write.table(meantotal12, "eg_data/NHANES/NHANES1516_total_d12_FC_mean.txt", sep="\t", row.names=F, quote=F)
# Load the mean total
meantotal12b <- read.table("eg_data/NHANES/NHANES1516_total_d12_FC_mean.txt", sep="\t", header=T)
# Define the input data.  This dataframe will be modified after each filter.
QCtotals <- meantotal12b
# ---------------------------------------------------------------------------------------------------------------
# For totals, the same QC can be applied as ASA24 totals QC procedure.
# Functions to clean ASA24 data.
source("lib/load_clean_ASA24.R")
# Define the input data.  This dataframe will be modified after each filter.
QCtotals <- meantotal12b
# Flag if KCAL is <600 or >5700 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "KCAL", min = 600, max = 5700)
# Flag if PROT is <10 or >240 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "PROT", min = 10, max = 240)
# Flag if TFAT is <15 or >230 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "TFAT", min = 15, max = 230)
# Flag if VC (Vitamin C) is <5 or >400 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "VC", min = 5, max = 400)
# or show the outliers if too many.
VCoutliers <- Outlier_rows[, c('SEQN', 'KCAL', 'VC')]
# Show the first n rows of the outliers in a descending order.
head(VCoutliers[order(VCoutliers$VC, decreasing = T), ], n=10)
# Flag if BCAR (beta-carotene) is <15 or >8200 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "BCAR", min = 15, max = 8200)
# Flag if KCAL is <600 or >5700 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "KCAL", min = 600, max = 5700)
# Flag if PROT is <10 or >240 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "PROT", min = 10, max = 240)
# Flag if TFAT is <15 or >230 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "TFAT", min = 15, max = 230)
# Flag if VC (Vitamin C) is <5 or >400 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "VC", min = 5, max = 400)
# Flag if BCAR (beta-carotene) is <15 or >8200 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "BCAR", min = 15, max = 8200)
# Show the first n rows of the outliers in a descending order.
head(bcaroutliers[order(bcaroutliers$BCAR, decreasing = T), ], n=10)
# Flag if BCAR (beta-carotene) is <15 or >8200 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotals,
target.colname = "BCAR", min = 15, max = 8200)
# or show the outliers if too many.
bcaroutliers <- Outlier_rows[, c('SEQN', 'KCAL', 'BCAR')]
# Show the first n rows of the outliers in a descending order.
head(bcaroutliers[order(bcaroutliers$BCAR, decreasing = T), ], n=10)
head(QCtotal)
length(unique(QCtotal$SEQN))
# Define the input data.  This dataframe will be modified after each filter.
QCtotal <- meantotal12b
# Flag if KCAL is <600 or >5700 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "KCAL", min = 600, max = 5700)
# Flag if PROT is <10 or >240 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "PROT", min = 10, max = 240)
# Flag if TFAT is <15 or >230 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "TFAT", min = 15, max = 230)
# Flag if VC (Vitamin C) is <5 or >400 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "VC", min = 5, max = 400)
View(QCOutliers)
# Flag outliers in the target column and min max values, and pop out a prompt asking whether to delete
# the outliers or not.
# Whether the outliers are removed or not, the output will be a df called 'QCtotal'.
QCOutliers <- function(input.data, target.colname, min, max){
temp <- input.data
# the nth column has the variable of interest.
nth_column <- which(colnames(temp) == target.colname )
# Extact rows that are NOT in the range of min-max.
Outlier_rows <<- temp[ temp[, nth_column] < min | temp[, nth_column] > max  , ]
# Report how many rows are outside the min-max range.
cat("There are", nrow(Outlier_rows), "observations with <", min, "or >", max, ". \n", sep = " ")
if(nrow(Outlier_rows) == 0){
QCtotal <<- temp
cat("There are no outlier rows, but the input data was renamed as QCtotal.\n",
nrow(QCtotal), "rows remained.\n")}
else{
answer <- askYesNo("Remove?")
if(answer==T){
# Save rows that are within the range of min-max as QCtotal.
QCtotal <<- temp[ temp[, nth_column] >= min & temp[, nth_column] <= max , ]
cat("Outlier rows were removed; the cleaned data is saved as an object called \"QCtotal\".\n",
nrow(QCtotal), "rows remained.\n")
}else{
QCtotal <<- temp
cat("Outlier rows were not removed, but the input data was renamed as QCtotal.\n",
nrow(QCtotal), "rows remained.\n")}
}
}
# Define the input data.  This dataframe will be modified after each filter.
QCtotal <- meantotal12b
# Flag if KCAL is <600 or >5700 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "KCAL", min = 600, max = 5700)
# Flag if PROT is <10 or >240 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "PROT", min = 10, max = 240)
# Flag if TFAT is <15 or >230 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "TFAT", min = 15, max = 230)
# Flag if VC (Vitamin C) is <5 or >400 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "VC", min = 5, max = 400)
# or show the outliers if too many.
VCoutliers <- Outlier_rows[, c('SEQN', 'KCAL', 'VC')]
# Show the first n rows of the outliers in a descending order.
head(VCoutliers[order(VCoutliers$VC, decreasing = T), ], n=10)
# Flag if BCAR (beta-carotene) is <15 or >8200 --> ask remove or not --> if yes, remove those rows
QCOutliers(input.data = QCtotal,
target.colname = "BCAR", min = 15, max = 8200)
# or show the outliers if too many.
bcaroutliers <- Outlier_rows[, c('SEQN', 'KCAL', 'BCAR')]
# Show the first n rows of the outliers in a descending order.
head(bcaroutliers[order(bcaroutliers$BCAR, decreasing = T), ], n=10)
# ---------------------------------------------------------------------------------------------------------------
# Save QCtotal as a .txt file.
write.table(QCtotal, "eg_data/NHANES/Total_D12_FC_mean_QC_1.txt", sep="\t", quote=F, row.names=F)
#
head(QCtotal)
# ========================================================================================
# Load data and keep only the individuals in QC-ed total data (optional; if wish to
# be consistent with clustering analysis using 'QCtotal')
# ========================================================================================
# Load the calculated and QC-ed total (after Scenario B-4).
QCtotal_a <- read.table("eg_data/NHANES/Total_D12_FC_mean_QC_1.txt", sep="\t", header=F)
# ========================================================================================
# Load data and keep only the individuals in QC-ed total data (optional; if wish to
# be consistent with clustering analysis using 'QCtotal')
# ========================================================================================
# Load the calculated and QC-ed total (after Scenario B-4).
QCtotal_a <- read.table("eg_data/NHANES/Total_D12_FC_mean_QC_1.txt", sep="\t", header=T)
head(QCtotal_a)
head(QCtotal_a$SEQN)
length(unique(QCtotal_a$SEQN))
selectedind <- unique(QCtotal_a$SEQN)
head(wwww, 1)
# <Optional>
# Load the input file to see what it looks like.
wwww = read.table("eg_data/NHANES/Food_D12_FC_cc_f.txt", sep="\t", header=T)
dim(wwww)
head(wwww, 1)
length(unique(wwww$SEQN))
ssss = wwww[wwww$SEQN %in% selectedind, ]
length(unique(ssss$SEQN))
# Confirm
identical(length(unique(ssss$SEQN)), length(selectedind))
# Save. This will be the input in the following procedures.
write.table(ssss, "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt", row.names=F, quote=F)
# ========================================================================================
# Limit to just the foods reported in your study (formatted dietrecords.txt as the input)
# ========================================================================================
# Keep only the foods reported in your study. This is already done, but need to run this
#  so that the data will be formatted in a compatible way to create food tree.
FilterDbByDietRecords(food_database_fn = "eg_data/NHANES1516/processed/NHANESDatabase.txt",
food_records_fn  = "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt",   # output of FormatFoods.
output_fn =        "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt")
# ========================================================================================
# Load source scripts
# ========================================================================================
source("lib/Food_tree_scripts/newick.tree.r")
source("lib/Food_tree_scripts/check.db.r")
source("lib/Food_tree_scripts/format.foods.r")
source("lib/Food_tree_scripts/filter.db.by.diet.records.r")
source("lib/Food_tree_scripts/make.food.tree.r")
source("lib/Food_tree_scripts/make.food.otu.r")
source("lib/Food_tree_scripts/make.fiber.otu.r")
source("lib/Food_tree_scripts/make.dhydrt.otu.r")
# ========================================================================================
# Limit to just the foods reported in your study (formatted dietrecords.txt as the input)
# ========================================================================================
# Keep only the foods reported in your study. This is already done, but need to run this
#  so that the data will be formatted in a compatible way to create food tree.
FilterDbByDietRecords(food_database_fn = "eg_data/NHANES1516/processed/NHANESDatabase.txt",
food_records_fn  = "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt",   # output of FormatFoods.
output_fn =        "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt")
# check if there is any food item reported by people but are missing in the database.
check.db(food_database_fn = "eg_data/NHANES1516/processed/NHANESDatabase.txt",
food_records_fn =  "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt",
output_fn =        "eg_data/NHANES/Food_D12_FC_cc_f_sel_red_missing.txt")
# Does the output contain anything?
rrr = read.table("eg_data/NHANES/Food_D12_FC_cc_f_sel_red_missing.txt", sep="\t", header=T)
head(rrr)
# Create food tree with the reduced dataset (only reported foods).
MakeFoodTree(nodes_fn="data/Food_tree_data/NodeLabelsMCT.txt", # can use this for now.
addl_foods_fn = NULL,
num.levels = 5,
food_database_fn= "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt",
output_tree_fn=      "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.txt",
output_taxonomy_fn = "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.taxonomy.txt"
)
# Create food tree with the reduced dataset (only reported foods).
MakeFoodTree(nodes_fn="data/Food_tree_data/NodeLabelsMCT.txt", # can use this for now.
addl_foods_fn = NULL,
num.levels = 5,
food_database_fn=    "eg_data/NHANES/Food_D12_FC_cc_f_red.txt",
output_tree_fn=      "results/Food_tree_NHANES/Food_D12_FC_cc_f_red_Lv5.txt",
output_taxonomy_fn = "results/Food_tree_NHANES/Food_D12_FC_cc_f_red_Lv5.taxonomy.txt"
)
# Save. This will be the input in the following procedures.
write.table(ssss, "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt", sep="\t", row.names=F, quote=F)
# ========================================================================================
# Limit to just the foods reported in your study (formatted dietrecords.txt as the input)
# ========================================================================================
# Keep only the foods reported in your study. This is already done, but need to run this
#  so that the data will be formatted in a compatible way to create food tree.
FilterDbByDietRecords(food_database_fn = "eg_data/NHANES1516/processed/NHANESDatabase.txt",
food_records_fn  = "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt",   # output of FormatFoods.
output_fn =        "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt")
# check if there is any food item reported by people but are missing in the database.
check.db(food_database_fn = "eg_data/NHANES1516/processed/NHANESDatabase.txt",
food_records_fn =  "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt",
output_fn =        "eg_data/NHANES/Food_D12_FC_cc_f_sel_red_missing.txt")
# Does the output contain anything?
rrr = read.table("eg_data/NHANES/Food_D12_FC_cc_f_sel_red_missing.txt", sep="\t", header=T)
head(rrr)
# Create food tree with the reduced dataset (only reported foods).
MakeFoodTree(nodes_fn="data/Food_tree_data/NodeLabelsMCT.txt", # can use this for now.
addl_foods_fn = NULL,
num.levels = 5,
food_database_fn=    "eg_data/NHANES/Food_D12_FC_cc_f_sel_red.txt",
output_tree_fn=      "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.txt",
output_taxonomy_fn = "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.taxonomy.txt"
)
# --------------------------------------------------------------------------------------------------------------
# Viz food tree.
source("lib/viz_food_tree.r")
tree <- read.tree("results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.txt")
PrepFoodTreePlots(input.tree=tree)
# Create a color-coded and annotated food tree with 9 L1 levels.
# Choose either 'circular' or 'radial' for layout.
# It is OK to see some warning messages about Coordinate system and scale for 'y' already being present.
VizFoodTree(input.tree=tree, layout="radial")
# Look at the color-coded and annotated food tree, saved as tree_an_hi_o_rt.
tree_an_hi_o_rt
colnames(wwww)
# Make the standard food otu table with data in gram weights of food.
MakeFoodOtu(food_records_fn=  "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt", # need to supply data that have 'FoodAmt' before applying FilterDBByDietRecords.
food_record_id =  "SEQN",                       # Specify the ID of your participants
food_taxonomy_fn= "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.taxonomy.txt",  # Specify your taxonomy file produced by MakeFoodTree.
output_fn =       "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.food.otu.txt")  # Name your output otu file.
# Make a food otu table with data in grams of fiber per food
MakeFiberOtu(food_records_fn=  "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt",
food_record_id=   "SEQN",
food_taxonomy_fn= "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.taxonomy.txt",
output_fn=        "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.fiber.otu.txt")
# Make a food otu table as dehydrated grams per kcal
MakeDhydrtOtu(food_records_fn=  "eg_data/NHANES/Food_D12_FC_cc_f_sel.txt",
food_record_id =  "SEQN",
food_taxonomy_fn= "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.taxonomy.txt",
output_fn =       "results/Food_tree_NHANES/Food_D12_FC_cc_f_sel_red_Lv5.dhydrt.otu.txt")
# ---------------------------------------------------------------------------------------------------------------
# Load the QC-ed total (with food categories)
# QCtotal <- read.table("eg_data/NHANES/NHANES1516_total_d12_FC_mean_QC_2.txt", sep="\t", header=T)  # OLD
QCtotal <- read.table("eg_data/NHANES/Total_D12_FC_mean_QC_1.txt", sep="\t", header=T) # filtered for KCAL, PROT, TFAT, VC, BCAR. 3992 people.
head(QCtotal)
length(unique(QCtotal$SEQN))
head(unique(QCtotal$SEQN))
tail(unique(QCtotal$SEQN))
# Load the metadata of people, which is in Total Day 1.
metadata_raw <- read.xport("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/DR1TOT_I.XPT")
head(metadata_raw, 2)
length(unique(metadata_raw$SEQN))
head(metadata_raw$SEQN)
# Load the body measure data and see.
bodymea <- read.xport("eg_data/NHANES/BodyMeasures/BMX_I.XPT")
# Pick up only the metadata of people in QCtotal.
keepnamesTF <- metadata_raw$SEQN %in% QCtotal$SEQN  # gives T or F for each.
head(keepnamesTF)
# Take only the participants whose names are in keepnamesTF
metadata <- metadata_raw[keepnamesTF, ]
head(metadata$SEQN)
# ---------------------------------------------------------------------------------------------------------------
# Take a look at how many people are following a specific diet?
table(metadata$DRQSDIET)
library(dplyr)
# Extract only those following any specific diet.
metadata_1 <- metadata %>% filter(DRQSDIET == 1)
# metadata_1 <- metadata %>% filter(DRQSDIET == 2)  # for checking.
# How many are on each diet?
table(metadata_1$DRQSDT1)
table(metadata_1$DRQSDT2)
table(metadata_1$DRQSDT3)
table(metadata_1$DRQSDT4)
table(metadata_1$DRQSDT5)
table(metadata_1$DRQSDT6)
table(metadata_1$DRQSDT7)
table(metadata_1$DRQSDT8)
table(metadata_1$DRQSDT9)
table(metadata_1$DRQSDT10)
table(metadata_1$DRQSDT11)
table(metadata_1$DRQSDT12)
table(metadata_1$DRQSDT91)
# Create a dataframe to count results.
# dietfreq = data.frame(diet=dietsvec, Yes=c(345, 94, 97, 37, 1, 7, 124, 14, 58, 15, 5, 5, 17))
dietfreq = data.frame(diet=dietsvec, Yes=c(317, 84, 91, 34, 1, 4, 112, 13, 54, 12, 3, 5, 14))
# Create a dataframe to count results.
# dietfreq = data.frame(diet=dietsvec, Yes=c(345, 94, 97, 37, 1, 7, 124, 14, 58, 15, 5, 5, 17))
dietfreq = data.frame(diet=dietsvec, Yes=c(317, 84, 91, 34, 1, 4, 112, 13, 54, 12, 3, 5, 14))
# Create a vector to use in a table to save count results.
dietsvec <- c("DRQSDT1","DRQSDT2","DRQSDT3","DRQSDT4","DRQSDT5","DRQSDT6","DRQSDT7","DRQSDT8","DRQSDT9","DRQSDT10","DRQSDT11","DRQSDT12","DRQSDT91")
# Create a dataframe to count results.
# dietfreq = data.frame(diet=dietsvec, Yes=c(345, 94, 97, 37, 1, 7, 124, 14, 58, 15, 5, 5, 17))
dietfreq = data.frame(diet=dietsvec, Yes=c(317, 84, 91, 34, 1, 4, 112, 13, 54, 12, 3, 5, 14))
sum(dietfreq$Yes)
# Count the number of diet variables that are not NA. If 13, they are not on a specific diet. If 12, they are on 1 diet. If < 12, they are on multiple diets.
metadata$count_na <- rowSums(is.na(metadata[, dietsvec])) # count number of NA's in the columns specified in "dietsvec".
table(metadata$count_na)
# Compute the number of diets they are on.
metadata$n_diets <- 13 - metadata$count_na
table(metadata$n_diets)
# So, 575 people are on 1 diet.
# So, 524 people are on 1 diet.
sum(metadata$n_diets) # Should be the same as sum(dietfreq$Yes).
# -----------------------------------------------------------------------------------------------------------------
# Append the name of the diet to metadata and freqtable.
# Load the dietcode and dietname reference table.
diettable <- read.table("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/NHANES_Totals_VarNames_Dietnames.txt", sep="\t", header=T)
# Create the number only dietcode...
diettable$dietcode_nonly <- c(1,2,3,4,5,6,7,8,9,10,11,12,91)
# Change the columnnames, to be able to do merge by dietcode.
colnames(diettable) <- c("dietcode_full", "dietname", "dietcode")
# Select only those following 1 diet. -------------------------------------------------------------------
metadata_a <- subset(metadata, n_diets==1)
dim(metadata_a)
head(metadata_a)
head(metadata_a, 1)
table(metadata_a$n_diets)  # OK
table(metadata_a$count_na) # OK
# Find the diet they are on.
# Calc rowSums for the diet columns. (because only the columns of the diet that each individual is on has a number, not NA.)
metadata_a$dietcode <- rowSums(metadata_a[, dietsvec], na.rm = T)
# Check
head(metadata_a[, c("SEQN", dietsvec, "dietcode")], 3)
# freq table of diets followed by them.
onedietfreq <- as.data.frame(table(metadata_a$dietcode))
colnames(onedietfreq)[1] <- "dietcode"
onedietfreq
# Append the dietname to the frequency table as well.
onedietfreq_name <- merge(x=onedietfreq, y=diettable, by="dietcode", all.x=T)
sum(onedietfreq_name$Freq) # Should total to the number of individuals following one diet.
onedietfreq_name
onedietfreq_name
# Add the dietname to metadata.
metadata_1diet <- merge(x=metadata_a, y=diettable, by="dietcode", all.x=T)
head(metadata_1diet,1)
# metadata_1diet has the metadata of the individuals who are in QCtotal and following one specific diet.
# Extract only necessary info.
metadata_b <- metadata_1diet[, c("SEQN", "dietcode", "dietname")]
head(metadata_b)
onedietfreq_name
# Sort by Freq
onedietfreq_name[sort(onedietfreq_name$Freq, decreasing=T), ]
sort(onedietfreq_name$Freq, decreasing=T)
sort(onedietfreq_name$Freq, decreasing=T)
order(onedietfreq_name$Freq, decreasing=T)
# Sort by Freq
onedietfreq_name[order(onedietfreq_name$Freq, decreasing=T), ]
# Sort by Freq and show Freq and dietname next to each other.
onedietfreq_name[order(onedietfreq_name$Freq, decreasing=T), c(1,2,4,3)]
