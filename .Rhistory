# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
# Define the input data to be used.
input_data <- mydata
# The columns specified as start.col, end.col, and all columns in between will be selected.
SubsetColumns(data=input_data, start.col="GRMS", end.col="NoOfItems")
View(KeepNonZeroVarColumns)
dim(subsetted_non0var)
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
selected_variables
# original
head(subsetted_non0var, 1)
dim(subsetted_non0var)
selected_variables
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
# ========================================================================================
# Perform Principal Component Analysis.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
# A biplot with the individuals labeled.
biplotlabeled <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label = T)
biplotlabeled
mydata = read.table(file="clipboard", sep="\t", header = T) # sep="," for 1 column, sep="\t" for multiple columns
head(mydata)
dim(mydata)
plot(mydata$PC1, mydata$PC2)
mydata = read.table(file="clipboard", sep="\t", header = T) # sep="," for 1 column, sep="\t" for multiple columns
head(mydata)
dim(mydata)
plot(mydata$PC1, mydata$PC2)
# Load the subsetted totals file.
totals_QCed_sampled <- read.table(        "eg_data/NHANES/NHANES1516_total_d12_mean_QC_2_500sampled.txt", sep="\t", header=T)
# Load the subsetted totals file.
totals_QCed_sampled <- read.table("eg_data/NHANES/NHANES1516_total_d12_mean_QC_2_500sampled.txt", sep="\t", header=T)
# Define the input data to be used.
input_data <- totals_QCed_sampled
# The columns specified as start.col, end.col, and all columns in between will be selected.
SubsetColumns(data=input_data, start.col="GRMS", end.col="NoOfItems")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
# original
head(subsetted_non0var, 1)
dim(subsetted_non0var)
# ========================================================================================
# Perform Principal Component Analysis.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
# A biplot with the individuals labeled.
biplotlabeled <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label = T)
biplotlabeled
# A biplot with the individuals labeled without the variables' arrows.
biplotlabeledwoarrows <- BiplotLabeledwoArrows(pca.result=scaled_pca, pca.data=pca_input,
individuals.label=T)
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.5, 0.01), ylim=c(-0.01, 0.01))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.5, 0.5), ylim=c(-0.01, 0.01))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.02, 0.02), ylim=c(-0.02, 0.02))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.02, 0.02), ylim=c(0.13, 0.16))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.10, 0.10), ylim=c(0.13, 0.16))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.2, 0.2), ylim=c(0.13, 0.16))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.2, 0.2), ylim=c(0.2, 0.4))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.2, 0.2), ylim=c(0.1, 0.3))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.2, 0.2), ylim=c(0.05, 0.2))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.2, 0.2), ylim=c(0.05, 0.1))
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
mydata = read.table(file="clipboard", sep="\t", header = T) # sep="," for 1 column, sep="\t" for multiple columns
head(mydata)
dim(mydata)
plot(mydata$PC1, mydata$PC2)
# Define the input data to be used.
input_data <- mydata
# The columns specified as start.col, end.col, and all columns in between will be selected.
SubsetColumns(data=input_data, start.col="GRMS", end.col="NoOfItems")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
# ========================================================================================
# Perform Principal Component Analysis.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
# A biplot with the individuals labeled.
biplotlabeled <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label = T)
biplotlabeled
# Plot the directions of the variables.
directions <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label=F)
directions
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
# ---------------------------------------------------------------------------------------------------------------
# Plot the contribution of each variable to PC1.
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", sort.variables=c(TRUE, FALSE)){
# Save the rotation (contribution of the Variables to each PC) as a dataframe.
Rota <- pca.result[["rotation"]]
Rotadf = as.data.frame(Rota)
# Make a column that contains the variable names (rownames).
Rotadf$Variables <- rownames(Rotadf)
# IF keeping the original order of the Variables --------------------------------------------
if(sort.variables==FALSE){
# Select the Variables and only the specified PC to plot.
aaa <- data.frame(Variables=Rotadf$Variables, Ytoplot= Rotadf[, whichPC])
# Make Variables as an ordered factor (the order of levels will be presereved).
aaa$Variables <- factor(aaa$Variables, levels=aaa$Variables)
# Calculate the position at which labels are placed for each bar.
n.PCx <- ifelse(aaa[, "Ytoplot"] > 0, yes= -0.01, no= aaa[, "Ytoplot"]-0.01)
# Assign each value a positive color and negative color.
c.PCx <- ifelse(aaa[, "Ytoplot"] > 0, yes=positive.color, no=negative.color)
# Make a plot with the original order of Variables.
loadings_plot <<- ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity", fill=c.PCx) +
theme_bw() +
labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.3, 0.1))) # give 0.3 space at the lower limit of Y (to fit text).
# IF sorting the Variables by their contributions ---------------------------------------
}else if(sort.variables==TRUE){
# Select the Variables and only the specified PC to plot.
bbb <- data.frame(Variables=Rotadf$Variables, Ytoplot= Rotadf[, whichPC])
# Sort the Variables in the order of Y (the contribution to the specified PC.)
bbb_s <- bbb[ order(bbb$Ytoplot, decreasing=T),  ]
# Make Variables as an ordered factor.
bbb_s$Variables <- factor(bbb_s$Variables, levels=bbb_s$Variables)
# Calculate the position at which labels are placed for each bar.
n.PCx <- ifelse(bbb_s[, "Ytoplot"] > 0, yes= -0.01, no= bbb_s[, "Ytoplot"]-0.01)
# Assign each value a positive color and negative color.
c.PCx <- ifelse(bbb_s[, "Ytoplot"] > 0, yes=positive.color, no=negative.color)
# Make a plot with the original order of the Variables.
loadings_plot <<- ggplot(data= bbb_s, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat='identity', fill=c.PCx) +
theme_bw() +
labs(y=paste0(whichPC)) +
theme(axis.ticks.x = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.3, 0.1))) # give 0.3 space at the lower limit of Y (to fit text).
}
}
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
# A biplot with the individuals labeled.
biplotlabeled <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label = T)
biplotlabeled
# A biplot with the individuals labeled without the variables' arrows.
biplotlabeledwoarrows <- BiplotLabeledwoArrows(pca.result=scaled_pca, pca.data=pca_input,
individuals.label=T)
biplotlabeledwoarrows +coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
biplotlabeledwoarrows #+coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
# A biplot with the individuals labeled without the variables' arrows.
biplotlabeledwoarrows <- BiplotLabeledwoArrows(pca.result=scaled_pca, pca.data=pca_input,
individuals.label=T)
biplotlabeledwoarrows #+coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
totals_QCed_sampled <- read.table("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_input_PCs_50.txt", sep="\t", header=T)
# Define the input data to be used.
input_data <- totals_QCed_sampled
colnames(input_data)
dim(input_data)
# The columns specified as start.col, end.col, and all columns in between will be selected.
SubsetColumns(data=input_data, start.col="GRMS", end.col="NoOfItems")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_rv.txt",
sep="\t", row.names=F, quote=F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn="results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_corr_mat.txt")
# ---------------------------------------------------------------------------------------------------------------
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
screep
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_screep.pdf", screep, device="pdf", width=5, height=5, units="in")
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_biplotdots.pdf", biplotdots, device="pdf", width=5, height=5, units="in")
# A biplot with the individuals labeled.
biplotlabeled <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label = T)
biplotlabeled
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_biplotlabeled.pdf", biplotlabeled, device="pdf", width=5, height=5, units="in")
# A biplot with the individuals labeled without the variables' arrows.
biplotlabeledwoarrows <- BiplotLabeledwoArrows(pca.result=scaled_pca, pca.data=pca_input,
individuals.label=T)
biplotlabeledwoarrows #+coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
ggsave("results/PCA_results/temporaryeg 50/total_d12_mean_QC500_2_50_biplotlabeledwoarrows.pdf", biplotlabeledwoarrows, device="pdf", width=5, height=5, units="in")
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_biplotlabeledwoarrows.pdf", biplotlabeledwoarrows, device="pdf", width=5, height=5, units="in")
# Plot the directions of the variables.
directions <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label=F)
directions
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_directions.pdf", directions, device="pdf", width=5, height=5, units="in")
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_loadings_PC2.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_loadings_PC1.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_loadings_PC1.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# ---------------------------------------------------------------------------------------------------------------
# Save the variance explained by each PC as a .txt file.
# Change the file name as necessary.
SaveVarExplained(pca.data = pca_input, pca.result = scaled_pca,
out.fn = "results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_PC_var_explained.txt")
# ---------------------------------------------------------------------------------------------------------------
# Calculate loadings of each PC to the variables and
# save it as a txt file in the results folder.
# Change the file name as necessary.
SaveLoadings(pca.result=scaled_pca,
out.fn="results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_PC_loadings.txt")
# ---------------------------------------------------------------------------------------------------------------
# Define your input file. Need to scale it to accommodate measurements in different units.
colnames(selected_variables)
kmeans_input <- scale(selected_variables) # correlated variables removed.
# Set your ggplot2 theme.
require(ggplot2)
theme_set(theme_bw(base_size = 14))
# ---------------------------------------------------------------------------------------------------------------
# Use the elbow method to find the ideal K.
ElbowMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
GapMethod(k.values = 1:15)
GapMethod(k.values = 1:15)
FactoextraGapMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with one specified k.
One_K(myK = 5)
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with multiple (2-4) Ks, and plot them in one window.
MultipleK(myKs = c(2,3,4,5))
GapMethod(k.values = 1:15)
FactoextraGapMethod(k.values = 1:15)
# Plot the directions of the variables.
directions <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label=F)
directions
# Use the only the 50 datapoints.
totals_QCed_sampled <- read.table("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_input_PCs_50.txt", sep="\t", header=T)
# Use the only the 50 datapoints.
totals_QCed_sampled <- read.table("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_input_PCs_50.txt", sep="\t", header=T)
# Define the input data to be used.
input_data <- totals_QCed_sampled
colnames(input_data)
dim(input_data)
# The columns specified as start.col, end.col, and all columns in between will be selected.
SubsetColumns(data=input_data, start.col="GRMS", end.col="NoOfItems")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
# original
head(subsetted_non0var, 1)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_rv.txt",
sep="\t", row.names=F, quote=F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn="results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_corr_mat.txt")
# ---------------------------------------------------------------------------------------------------------------
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# A biplot with the individuals labeled without the variables' arrows.
biplotlabeledwoarrows <- BiplotLabeledwoArrows(pca.result=scaled_pca, pca.data=pca_input,
individuals.label=T)
biplotlabeledwoarrows #+coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
# Plot the directions of the variables.
directions <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label=F)
directions
ggsave("results/PCA_results/temporary/eg 50/total_d12_mean_QC500_2_50_directions.pdf", directions, device="pdf", width=5, height=5, units="in")
# use this working directory until this script is complete.
setwd("~/GitHub/dietary_patterns")
# Name your main directory for future use.
main.wd <- file.path(getwd())
# ========================================================================================
# Load source scripts
# ========================================================================================
source("lib/Food_tree_scripts/newick.tree.r")
source("lib/Food_tree_scripts/check.db.r")
source("lib/Food_tree_scripts/format.foods.r")
source("lib/Food_tree_scripts/filter.db.by.diet.records.r")
source("lib/Food_tree_scripts/make.food.tree.r")
source("lib/Food_tree_scripts/make.food.otu.r")
source("lib/Food_tree_scripts/make.fiber.otu.r")
source("lib/Food_tree_scripts/make.dhydrt.otu.r")
# read in food description files
# foodcodes <- sasxport.get("data/NHANES/DRXFCD_G.XPT")
foodcodes <- sasxport.get("eg_data/NHANES/FoodCodes_DRXFCD_I.XPT")
library(SASxport)
# read in food description files
# foodcodes <- sasxport.get("data/NHANES/DRXFCD_G.XPT")
foodcodes <- sasxport.get("eg_data/NHANES/FoodCodes_DRXFCD_I.XPT")
library(foreign)
# read in food description files
# foodcodes <- sasxport.get("data/NHANES/DRXFCD_G.XPT")
foodcodes <- sasxport.get("eg_data/NHANES/FoodCodes_DRXFCD_I.XPT")
# read in food description files
# foodcodes <- sasxport.get("data/NHANES/DRXFCD_G.XPT")
foodcodes <- read.xport("eg_data/NHANES/FoodCodes_DRXFCD_I.XPT")
food1 <- read.xport("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/Interview_IndFoods_Day1_DR1IFF_I.XPT")
# food2 <- read.xport("data/NHANES/DR2IFF_G.XPT")
food2 <- read.xport("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/Interview_IndFoods_Day2_DR1IFF_I.XPT")
# food2 <- read.xport("data/NHANES/DR2IFF_G.XPT")
food2 <- read.xport("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/Interview_IndFoods_Day2_DR2IFF_I.XPT")
tots1 <- read.xport("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/Total_Nutrient_Day1_DR1TOT_J.XPT")
tots2 <- read.xport("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16/Data/Total_Nutrient_Day2_DR2TOT_J.XPT")
# demo <- read.xport("data/NHANES/DEMO_G.XPT")
demo <- read.xport("eg_data/NHANES/DEMO_I.XPT")
adults <- demo[demo$ridageyr >= 18,]
# Quality filtering
# did the food recall meet the minimum criteria to be considered reliable?
food1 <- food1[food1$dr1drstz == 1,] # this drops people with unreliable records and breastfed children
food2 <- food2[food2$dr2drstz == 1,]
# fix nameing for downstream food tree use
names(food1)[names(food1) == "dr1ifdcd"] <- "FoodCode"
names(food1)
names(food1)[names(food1) == "DR1IFDCD"] <- "FoodCode"
names(food1)
