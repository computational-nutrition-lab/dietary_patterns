text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
# Function
# ---------------------------------------------------------------------------------------------------------------
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", labels.aligned=c(TRUE, FALSE)){
p <- pca.result[["rotation"]]
print(p)
variables <-  rownames(p)
print(variables)
# create a numeric object ("n.pc1") containing values which will position text underneath the bars.
# i.e. shows the starting points for the label of the variables.
n.PCx <- ifelse(p[, whichPC] > 0, yes= -0.01, no= p[, whichPC]-0.01)
print(n.PCx)
# if loadings is positive, color it green, if not, color it red.
c.PCx <- ifelse(p[, whichPC] > 0, yes=positive.color, no=negative.color)
print(c.PCx)
if(labels.aligned==TRUE){
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(scaled_pca$rotation[,1], main="PC 1 Loadings Plot", col=c.pc1, las=2, axisnames=T)
abline(h=0) # Add horizontal line
}if(labels.aligned==FALSE){
# Plot again
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=FALSE)
abline(h=0) # Add horizontal line
#
text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
# Function
# ---------------------------------------------------------------------------------------------------------------
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", labels.aligned=c(TRUE, FALSE)){
p <- pca.result[["rotation"]]
# print(p)
variables <-  rownames(p)
# print(variables)
# create a numeric object ("n.pc1") containing values which will position text underneath the bars.
# i.e. shows the starting points for the label of the variables.
n.PCx <- ifelse(p[, whichPC] > 0, yes= -0.01, no= p[, whichPC]-0.01)
print(n.PCx)
# if loadings is positive, color it green, if not, color it red.
c.PCx <- ifelse(p[, whichPC] > 0, yes=positive.color, no=negative.color)
print(c.PCx)
if(labels.aligned==TRUE){
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(scaled_pca$rotation[,1], main="PC 1 Loadings Plot", col=c.pc1, las=2, axisnames=T)
abline(h=0) # Add horizontal line
}else{
# Plot again
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=FALSE)
abline(h=0) # Add horizontal line
#
text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= T)
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= F)
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70")
# Function
# ---------------------------------------------------------------------------------------------------------------
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", labels.aligned=c(TRUE, FALSE)){
p <- pca.result[["rotation"]]
# print(p)
variables <-  rownames(p)
# print(variables)
# create a numeric object ("n.pc1") containing values which will position text underneath the bars.
# i.e. shows the starting points for the label of the variables.
n.PCx <- ifelse(p[, whichPC] > 0, yes= -0.01, no= p[, whichPC]-0.01)
print(n.PCx)
# if loadings is positive, color it green, if not, color it red.
c.PCx <- ifelse(p[, whichPC] > 0, yes=positive.color, no=negative.color)
print(c.PCx)
if(labels.aligned==TRUE){
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(scaled_pca$rotation[,1], main="PC 1 Loadings Plot", col=c.pc1, las=2, axisnames=T)
abline(h=0) # Add horizontal line
}if(labels.aligned==FALSE){
# Plot again
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=FALSE)
abline(h=0) # Add horizontal line
#
text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
# Function
# ---------------------------------------------------------------------------------------------------------------
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", labels.aligned=c(TRUE, FALSE)){
p <- pca.result[["rotation"]]
# print(p)
variables <-  rownames(p)
# print(variables)
# create a numeric object ("n.pc1") containing values which will position text underneath the bars.
# i.e. shows the starting points for the label of the variables.
n.PCx <- ifelse(p[, whichPC] > 0, yes= -0.01, no= p[, whichPC]-0.01)
print(n.PCx)
# if loadings is positive, color it green, if not, color it red.
c.PCx <- ifelse(p[, whichPC] > 0, yes=positive.color, no=negative.color)
print(c.PCx)
if(labels.aligned==TRUE){
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(scaled_pca$rotation[,1], main="PC 1 Loadings Plot", col=c.pc1, las=2, axisnames=T)
abline(h=0) # Add horizontal line
}else if(labels.aligned==FALSE){
# Plot again
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=FALSE)
abline(h=0) # Add horizontal line
#
text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= T)
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= F)
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70")
# Plot the contribution of the variables to a given PC.
# Variables' labels aligned on the X axis.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= TRUE)
# Variables' labels are placed right below the bars.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= FALSE)
# Function
# ---------------------------------------------------------------------------------------------------------------
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", labels.aligned=c(TRUE, FALSE)){
p <- pca.result[["rotation"]]
variables <- rownames(p)
# create a numeric object ("n.pc1") containing values which will position text underneath the bars.
# i.e. shows the starting points for the label of the variables.
n.PCx <- ifelse(p[, whichPC] > 0, yes= -0.01, no= p[, whichPC]-0.01)
# if loadings is positive, color it green, if not, color it red.
c.PCx <- ifelse(p[, whichPC] > 0, yes=positive.color, no=negative.color)
if(labels.aligned==TRUE){
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(scaled_pca$rotation[,1], main="PC 1 Loadings Plot", col=c.pc1, las=2, axisnames=T)
abline(h=0) # Add horizontal line
}else if(labels.aligned==FALSE){
# Plot again
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=FALSE)
abline(h=0) # Add horizontal line
#
text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= T)
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70", labels.aligned= F)
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1", positive.color="green2", negative.color="grey70")
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = T)
# Create a scree plot.
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
BiplotDots(pca.result = scaled_pca, pca.data = pca_input)
# A biplot with the individuals labeled.
BiplotLabeled(pca.result = scaled_pca,
pca.data = pca_input,
individuals.label = T)
# Look at the entry
head(pca_input)
# Look at the entry
dim(pca_input)
# But useful to see which element in the PCA results are what.
data <- (iris)
iris <- data[,1:4]
species <- data[,5]
variables = colnames(iris)
# apply pca
pca <- prcomp(iris, center = TRUE, scale = TRUE)
summ = summary(pca)
# extract scores and loadings
scores    <- as.data.frame(pca$x)
loadings  <- as.data.frame(pca$rotation)
label     <- species
variables <- rownames(loadings)
# make a biplot, but the arrows are too short.
ggplot()+
geom_point(data = scores, aes(x=PC1, y=PC2, colour = factor(label)))+
geom_segment(data = loadings, aes(x=0,y=0,xend=PC1,yend=PC2),
arrow=arrow(length=unit(0.1,"cm")), color = "#DCDCDC")+
geom_text(data = loadings, aes(x=PC2, y=PC3), label=variables, color="#006400")
# Use my function which uses ggfortify::autoplot
BiplotLabeled(pca.result = pca, pca.data = iris, individuals.label = TRUE)
iris(42,)
iris[42,]
pca$x[42, ]
pca$x[61, ]
# A biplot with the individuals labeled.
BiplotLabeled(pca.result = scaled_pca,
pca.data = pca_input,
individuals.label = T)
# Look at the outstanding entry
pca_input[, 419]
# Look at the outstanding entry
pca_input[419, ]
# Load the QC-ed and sampled totals file.
totals_QCed_1500 <- read.table("NHANES_totals_QCed_1500.txt", sep="\t", header=T)
# Load total nutrient intake of day 1 or day 2. Day 1 has more columns that can be used as metadata.
nhanes1516_totals1 <- read.xport('Total_Nutrient_Day1_DR1TOT_J.XPT')
# Load necessary functions.
source("~/GitHub/dietary_patterns/lib/load_clean_NHANES.R")
# Set where the NHANES data and food code table are.
# it is not in the eg_data folder because it's too large to save in GitHub folder.
setwd("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16")
# Load total nutrient intake of day 1 or day 2. Day 1 has more columns that can be used as metadata.
nhanes1516_totals1 <- read.xport('Total_Nutrient_Day1_DR1TOT_J.XPT')
# e.g. only day 1 has Number of times mackerel eaten past 30 days
hist(nhanes1516_totals1$DRD370HQ)
# Intake of the day
hist(nhanes1516_totals1$DR1DAY)
# On a special diet?
table(nhanes1516_totals1$DRQSDIET)
# KCAL on that day
hist(nhanes1516_totals1$DR1TKCAL)
# How many participants in the total dataset?
length(unique(nhanes1516_totals1$SEQN))
# ---------------------------------------------------------------------------------------------------------------
# Status code - Only retain complete entries.
# Code descriptions in Analytic notes: https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/DR1IFF_J.htm#Analytic_Notes
#  1: reliable and all relevant variables associated with the 24-hour dietary recall contain a value.
table(nhanes1516_totals1$DR1DRSTZ)
# Take only DR1DRSTZ = 1
nhanes_totals_1 <- subset(nhanes1516_totals1, DR1DRSTZ == 1)
table(nhanes_totals_1$DR1DRSTZ)
# How many participants selected?
length(unique(nhanes_totals_1$SEQN))
# ---------------------------------------------------------------------------------------------------------------
# For totals, the same QC can be applied as ASA24 totals QC procedure.
# Functions to clean ASA24 data.
source("~/GitHub/dietary_patterns/lib/load_clean_ASA24.R")
# Define the input data.  This will be modified after each filter.
QCtotals <- nhanes_totals_1
# ---------------------------------------------------------------------------------------------------------------
# Save QCtotals as "Totals_QCed.txt"
write.table(QCtotals, "NHANES_totals_QCed.txt", sep="\t", quote=F, row.names=F)
# ---------------------------------------------------------------------------------------------------------------
# Take n random samples of participants.
RandomSample(data = QCtotals, n=30, out.fn = "NHANES_totals_QCed_sampled.txt")
# Load the QC-ed and sampled totals file.
totals_QCed_1500 <- read.table("NHANES_totals_QCed_sampled.txt", sep="\t", header=T)
# Load the QC-ed and sampled totals file.
totals_QCed_sampled <- read.table("NHANES_totals_QCed_sampled.txt", sep="\t", header=T)
# TOTALS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the input data to be used.
input_data <- totals_QCed_sampled
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Totals  --> start.col = "DR1TPROT",    end.col = "DR1TP226"
SubsetColumns(data=input_data, start.col="DR1TPROT", end.col = "DR1TP226")
# pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# The out put is a df called "subsetted_non0var".
colnames(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
# original
head(subsetted_non0var, 1)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc, out.fn = "NHANEStotals_corr_matrix.txt")
setwd("~/GitHub/dietary_patterns")
# Name your main directory for future use.
main.wd <- file.path(getwd())
# Import source code to run the analyses to follow.
source("lib/specify_dir_and_check_col.R")
source("lib/prep_data_for_clustering.R")
source("lib/PCA.R")
source("lib/PCA.R")
# Define ggplot themes to use in creating plots.
library(ggplot2)
ggplot2::theme_set(theme_bw(base_size = 14))
# ========================================================================================
# Perform Principal Component Analysis.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = T)
# Create a scree plot.
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = T)
length(colnames(pca.data))
length(colnames(pca_input))
scaled_pca$sdev
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = T)
# Create a scree plot.
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
dim(pca_input)
# Create a scree plot.
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
var_explained_df <- data.frame(PC = rep(1:length(colnames(pca_input))),
var_explained = (scaled_pca$sdev)^2/sum((scaled_pca$sdev)^2))
dim(pca_input)
scaled_pca$sdev
screeplot(p)                     # stats package, loaded by default
# PCA using base function - prcomp()
pr <- prcomp(ma.pollen1, scale=TRUE)
# Summary
s <- summary(p)
s
# Screeplot
layout(matrix(1:2, ncol=2))
screeplot(p)                     # stats package, loaded by default
unclass(p)
screeplot(p)                     # stats package, loaded by default
screeplot(p, type="lines")
# Summary
s <- summary(pr)
unclass(pr)
screeplot(pr)                     # stats package, loaded by default
screeplot(pr, type="lines")
s
var_exp = summary(scaled_pca)
var_exp
var_exp[1,1]
var_exp[,1]
var_exp1 = as.data.frame(var_exp)
var_exp1 = data.frame(var_exp)
var_exp[["importance"]]
var_exp[["importance"]](1, )
var_exp[["importance"]][1, ]
var_exp[["importance"]][1,1 ]
var_exp[["importance"]][3, 1]
var_exp
var_exp <- pca_summary[["importance"]]
pca_summary = summary(scaled_pca)
pca_summary[["importance"]][3, 1] *100 # var explained by PC1 (%)
var_exp <- pca_summary[["importance"]]
var_exp
colnames(pca_input)
nrow(pca_input)
var_explained_df <- data.frame(PC = rep(1:nrow(pca_input)),
var_explained = pca_summary[["importance"]][3, ] *100)
var_explained_df
# ---------------------------------------------------------------------------------------------------------------
# Function to create a scree plot.
# If there are 10 or less PCs in total, plot all, and else plot the first 10 PCs.
LineScreePlot <- function(pca.data = pca_input, pca.result = scaled_pca){
# Calculate the variance explained for each PC.
# var_explained_df <<- data.frame(PC = rep(1:length(colnames(pca.data))),
#                                var_explained = (pca.result$sdev)^2/sum((pca.result$sdev)^2))
# Extract the importance of the PCs
pca_summary = summary(pca.result)
# Create a dataframe that has the PCs and their importance (var explained by each PC)
var_explained_df <- data.frame(PC = rep(1:nrow(pca.data)),
var_explained = pca_summary[["importance"]][3, ])
# if there are only 9 or fewer variables, plot them all; otherwise plot the first 10 PCs.
if(length(colnames(pca.data))<10){
myPCs <<- var_explained_df
}else{
myPCs <<- var_explained_df[1:10, ]    # Subset the first 10 PCs
}
# Create a scree plot.
require(ggplot2)
ggplot(myPCs, aes(x = PC, y = var_explained*100)) +
geom_line() +
geom_point() +
scale_x_continuous(breaks = 1:nrow(myPCs)) +
labs(x = "Number of PCs",
y = "Variance explained by PCs (%)") +
theme_bw(base_size = 13) +
theme(panel.grid.major = element_blank()) +
theme(panel.grid.minor = element_blank()) +
theme(axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ) ) +
theme(axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
theme(aspect.ratio = 0.9)
}
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
v
var_explained_df
# ---------------------------------------------------------------------------------------------------------------
# Function to create a scree plot.
# If there are 10 or less PCs in total, plot all, and else plot the first 10 PCs.
LineScreePlot <- function(pca.data = pca_input, pca.result = scaled_pca){
# Calculate the variance explained for each PC.
# var_explained_df <<- data.frame(PC = rep(1:length(colnames(pca.data))),
#                                var_explained = (pca.result$sdev)^2/sum((pca.result$sdev)^2))
# Extract the importance of the PCs
pca_summary = summary(pca.result)
# Create a dataframe that has the PCs and their importance (var explained by each PC)
var_explained_df <- data.frame(PC = rep(1:nrow(pca.data)),
var_explained = pca_summary[["importance"]][2, ])
# if there are only 9 or fewer variables, plot them all; otherwise plot the first 10 PCs.
if(length(colnames(pca.data))<10){
myPCs <<- var_explained_df
}else{
myPCs <<- var_explained_df[1:10, ]    # Subset the first 10 PCs
}
# Create a scree plot.
require(ggplot2)
ggplot(myPCs, aes(x = PC, y = var_explained*100)) +
geom_line() +
geom_point() +
scale_x_continuous(breaks = 1:nrow(myPCs)) +
labs(x = "Number of PCs",
y = "Variance explained by PCs (%)") +
theme_bw(base_size = 13) +
theme(panel.grid.major = element_blank()) +
theme(panel.grid.minor = element_blank()) +
theme(axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ) ) +
theme(axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
theme(aspect.ratio = 0.9)
}
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
# ========================================================================================
# Perform Principal Component Analysis.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
dim(pca_input)
# Create a scree plot.
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
# Create a scree plot.
LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
BiplotDots(pca.result = scaled_pca, pca.data = pca_input)
# A biplot with the individuals labeled.
BiplotLabeled(pca.result = scaled_pca,
pca.data = pca_input,
individuals.label = T)
# A biplot with the individuals labeled without the variables' arrows.
BiplotLabeledwoArrows(pca.result = scaled_pca,
pca.data = pca_input,
individuals.label = T)
# A The directions of the variables.
BiplotLabeled(pca.result = scaled_pca,
pca.data = pca_input,
individuals.label = F)
# Plot the contribution of the variables to a given PC.
# Variables' labels aligned on the X axis.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= TRUE)
# Variables' labels are placed right below the bars.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= FALSE)
# Plot the contribution of the variables to a given PC.
# Variables' labels aligned on the X axis.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= TRUE)
# Variables' labels are placed right below the bars.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= FALSE)
# Plot the contribution of the variables to a given PC.
# Variables' labels aligned on the X axis.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= TRUE)
# Variables' labels are placed right below the bars.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= FALSE)
# Plot the contribution of the variables to a given PC.
# Variables' labels aligned on the X axis.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= TRUE)
# ---------------------------------------------------------------------------------------------------------------
# Plot the contribution of each variable to PC1.
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", labels.aligned=c(TRUE, FALSE)){
p <- pca.result[["rotation"]]
variables <- rownames(p)
# create a numeric object ("n.pc1") containing values which will position text underneath the bars.
# i.e. shows the starting points for the label of the variables.
n.PCx <- ifelse(p[, whichPC] > 0, yes= -0.01, no= p[, whichPC]-0.01)
# if loadings is positive, color it green, if not, color it red.
c.PCx <- ifelse(p[, whichPC] > 0, yes=positive.color, no=negative.color)
if(labels.aligned==TRUE){
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=T)
abline(h=0) # Add horizontal line
}else if(labels.aligned==FALSE){
# Plot again
par(mar=c(8,3,2,1)) # Set margins
b1 <- barplot(p[, whichPC], main=paste("PC", whichPC, "Loadings Plot"), col=c.PCx, las=2, axisnames=FALSE)
abline(h=0) # Add horizontal line
#
text(x=b1, y=n.PCx, labels= names(n.PCx), adj=1, srt=90, xpd= TRUE) # Add variable names
# xpd=TRUE tells R that it can plot the text outside the plot region.
}
}
# Plot the contribution of the variables to a given PC.
# Variables' labels aligned on the X axis.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= TRUE)
# Variables' labels are placed right below the bars.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", labels.aligned= FALSE)
