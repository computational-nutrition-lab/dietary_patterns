# plot samples (by gender, timing, people, etc as in the meta file)
p2 = plot_ordination(phyfoods3, ordmct4, type="samples", color="UserName") # ordmct4(unweighted) & UserName
p2
p2 + geom_point(size=2) + theme(aspect.ratio = 1) + geom_line()
# --------------------------------------------------------------------------------------------------------
# What are the dark yellow points in samples plot by UserName that are kind of far away from other users?
# extract vectors
vectors <- as.data.frame(ordmct3[4])
vectors <- vectors[, c("vectors.Axis.1", "vectors.Axis.2")]
colnames(vectors)
head(vectors)
# Show points with the highest Axis.1 values.
sortedv <- vectors[order(vectors$vectors.Axis.1, decreasing = T), ]
sortedv1 <- subset(sortedv, vectors.Axis.1 > 0.05 & vectors.Axis.2 > 0.04)
nrow(sortedv1)
# Match UserName
head(meta, 1)
# make rownames as a column for merging.
meta$MCTXXX     <- rownames(meta)
sortedv1$MCTXXX <- rownames(sortedv1)
# Match MCTXXX (sample ID) and UserName.
sortedv1name <- merge(sortedv1, meta, by="MCTXXX", all.x=T)
head(sortedv1name)
table(sortedv1name$UserName)
sortedv1name[, 1:4]
# --------------------------------------------------------------------------------------------------------
# What are the purple points in taxa(foods) plot that are so far away from everyone else?
# extract vectors
vectors <- as.data.frame(ordmct4[4])
head(vectors)
vectors <- vectors[, c("vectors.Axis.1", "vectors.Axis.2")]
colnames(vectors)
head(vectors)
# Show points with the highest Axis.1 values.
sortedv <- vectors[order(vectors$vectors.Axis.1, decreasing = T), ]
tail(vectors)
# --------------------------------------------------------------------------------------------------------
# What are the green points in samples plot by UserName that are far away from everyone else?
# extract vectors
vectors <- as.data.frame(ordmct4[4])
vectors <- vectors[, c("vectors.Axis.1", "vectors.Axis.2")]
colnames(vectors)
head(vectors)
# Show points with the highest Axis.1 values.
sortedv <- vectors[order(vectors$vectors.Axis.1, decreasing = T), ]
sortedv1 <- subset(sortedv, vectors.Axis.1 > 0.2)
nrow(sortedv1)
# Match UserName
head(meta, 1)
# make rownames as a column for merging.
meta$MCTXXX     <- rownames(meta)
sortedv1$MCTXXX <- rownames(sortedv1)
# Match MCTXXX (sample ID) and UserName.
sortedv1name <- merge(sortedv1, meta, by="MCTXXX", all.x=T)
sortedv1name
table(sortedv1name$UserName)
GP1
phyfoods3
GP = GlobalPatterns
# Remove OTUs that do not show appear more than 5 times in more than half the samples
wh0 = genefilter_sample(GP, filterfun_sample(function(x) x > 5), A=0.5*nsamples(GP))
GP1 = prune_taxa(wh0, GP)
# Transform to even sampling depth.
GP1 = transform_sample_counts(GP1, function(x) 1E6 * x/sum(x))
# Keep only the most abundant five phyla.
phylum.sum = tapply(taxa_sums(GP1), tax_table(GP1)[, "Phylum"], sum, na.rm=TRUE)
top5phyla = names(sort(phylum.sum, TRUE))[1:5]
GP1 = prune_taxa((tax_table(GP1)[, "Phylum"] %in% top5phyla), GP1)
GP1
# ========================================================================================
# Load the packages and functions needed.
# ========================================================================================
# Bio
BiocManager::install("phyloseq")
setwd("~/GitHub/dietary_patterns")
# Name your main directory for future use.
main.wd <- file.path(getwd())
# load the necessary packages.
library(phyloseq)
library(ggtree)
library(ggplot)
library(ggplot2)
PrepFood()
# Prep data behind the scene...
# prep food data.
PrepFood <- function(data=food){data <- data[, !colnames(data) == "taxonomy"]} # remove taxonomy column
# Food OTU table - this is our food OTU data
food <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.dhydrt.otu.txt", row.names = 1)
# Format the food file.
PrepFood(data=food)
# Format the food file.
PrepFood(data=food)
head(data)
head(food)
# Prep data behind the scene...
# prep food data.
PrepFood <- function(data=food){
wotax <- data[, !colnames(data) == "taxonomy"] # remove the taxonomy column
data <<- wotax}
# Food OTU table - this is our food OTU data
food <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.dhydrt.otu.txt", row.names = 1)
# Format the food file.
PrepFood(data=food)
# Prep data behind the scene...
# prep food data.
PrepFood <- function(data=food){
wotax <- data[, !colnames(data) == "taxonomy"] # remove the taxonomy column
food2 <<- wotax}
# Format the food file.
PrepFood(data=food)
head(food2)
PrepTax <- function(data=tax){
row.names(data) <<- data$Main.food.description # Make the food description as row names
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
# taxonomy (food names) data
colnames(tax)
PrepTax <- function(data=tax){
row.names(data) <- data$Main.food.description # Make the food description as row names
}
# Format the tax file and save as tax2.
PrepTax(data=tax)
PrepTax <- function(data=tax){
row.names(data) <- data$Main.food.description # Make the food description as row names
woFoodID <<- data[, !colnames(data) == "FoodID"] # remove FoodID column
}
# Format the tax file and save as tax2.
PrepTax(data=tax)
View(woFoodID)
before = data.frame(attr = c(1,30,4,6), type=c('foo_and_bar','foo_and_bar_2'))
before
n <- 1
?strsplit
for(i in strsplit(as.character(before$type), split='_and_')){
before[n, 'type_1'] <- i[[1]]
before[n, 'type_2'] <- i[[2]]
n <- n + 1
}
before
# taxonomy (food names) data
colnames(tax)
head(tax, 2)
before = head(tax, 20)
n <- 1
before
for(i in strsplit(as.character(before$taxonomy), split=';')){
before[n, 'L1'] <- i[[1]]
before[n, 'L2'] <- i[[2]]
before[n, 'L3'] <- i[[3]]
before[n, 'L4'] <- i[[4]]
before[n, 'L5'] <- i[[5]]
n <- n + 1
}
before
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
# tax <- read.delim("Dropbox/Food_Tree/R/output/mct.taxonomy.txt")
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
colnames(tax)
n <- 1
before = head(tax, 20)
n <- 1
for(i in strsplit(as.character(before$taxonomy), split=';')){
before[n, 'L1'] <- i[[1]]
before[n, 'L2'] <- i[[2]]
before[n, 'L3'] <- i[[3]]
before[n, 'L4'] <- i[[4]]
# before[n, 'L5'] <- i[[5]]
n <- n + 1
}
before
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# drop the last column (Main.food.description because it's already made into row names.)
#tax <- tax[, -length(colnames(tax))]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
head(tax)
head(woFoodID)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# drop the last column, Main.food.description, because it's already made into row names.
woFoodID <- woFoodID[, -length(colnames(woFoodID))]
}
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# drop the last column, Main.food.description, because it's already made into row names.
woFoodID <<- woFoodID[, -length(colnames(woFoodID))]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
head(woFoodID)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# drop the last column, Main.food.description, because it's already made into row names.
woFoodID2 <<- woFoodID[, -length(colnames(woFoodID))]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
head(woFoodID)
colnames(woFoodID)
# Format the tax file and save as tax2.
PrepTax(data=tax)
colnames(woFoodID2)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# drop the last column, Main.food.description, because it's already made into row names.
woFoodID2 <<- woFoodID[, -"Main.food.description"]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove Main.food.description column, because it's already made into row names.
woFoodID <<- data[, !colnames(data) == "Main.food.description"]
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
}
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove Main.food.description column, because it's already made into row names.
woMFD <<- data[, !colnames(data) == "Main.food.description"]
# remove the FoodID column
woFoodID <<- woMFD[, !colnames(woMFD) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove Main.food.description column, because it's already made into row names.
woMFD <<- data[, !colnames(data) == "Main.food.description"]
# # remove the FoodID column
# woFoodID <<- woMFD[, !colnames(woMFD) == "FoodID"]
#
# # Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
#   # tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
#   n <- 1
#   for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
#     woFoodID[n, 'L1'] <<- i[[1]]
#     woFoodID[n, 'L2'] <<- i[[2]]
#     woFoodID[n, 'L3'] <<- i[[3]]
#     woFoodID[n, 'L4'] <<- i[[4]]
#     woFoodID[n, 'L5'] <<- i[[5]]
#     n <- n + 1
#   }
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
colnames(woMFD)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove Main.food.description column, because it's already made into row names.
woMFD <<- data[, !colnames(data) == "Main.food.description"]
# remove the FoodID column
woFoodID <<- woMFD[, !colnames(woMFD) == "FoodID"]
#
# # Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
#   # tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
#   n <- 1
#   for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
#     woFoodID[n, 'L1'] <<- i[[1]]
#     woFoodID[n, 'L2'] <<- i[[2]]
#     woFoodID[n, 'L3'] <<- i[[3]]
#     woFoodID[n, 'L4'] <<- i[[4]]
#     woFoodID[n, 'L5'] <<- i[[5]]
#     n <- n + 1
#   }
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
colnames(woMFD)
colnames(woFoodID)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
#
# # Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
#   # tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
#   n <- 1
#   for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
#     woFoodID[n, 'L1'] <<- i[[1]]
#     woFoodID[n, 'L2'] <<- i[[2]]
#     woFoodID[n, 'L3'] <<- i[[3]]
#     woFoodID[n, 'L4'] <<- i[[4]]
#     woFoodID[n, 'L5'] <<- i[[5]]
#     n <- n + 1
#   }
# remove Main.food.description column, because it's already made into row names.
# woMFD <<- data[, !colnames(data) == "Main.food.description"]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
colnames(woFoodID)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# remove Main.food.description column, because it's already made into row names.
# woMFD <<- data[, !colnames(data) == "Main.food.description"]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
colnames(woFoodID)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# remove Main.food.description column, because it's already made into row names.
woFoodID2 <<- woFoodID[, !colnames(woFoodID) == "Main.food.description"]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
colnames(woFoodID)
colnames(woFoodID2)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
n <- n + 1
}
# remove Main.food.description column, because it's already made into row names.
woFoodID2 <<- woFoodID[, !colnames(woFoodID) == "Main.food.description"]
}
colnames(tax)
woFoodID = head(tax, 20)
strsplit(as.character(woFoodID$taxonomy), split=';'))
strsplit(as.character(woFoodID$taxonomy), split=';' )
mysplit = strsplit(as.character(woFoodID$taxonomy), split=';' )
is(mysplit)
PrepTax <- function(data=tax, nlevels=5){  # split taxonomy into 5 levels by default.  need to check if it works with other dataset than
# Make the food description as row names
row.names(data) <- data$Main.food.description
# remove the FoodID column
woFoodID <<- data[, !colnames(data) == "FoodID"]
# Split taxonomy L1, L2, L3 etc. by a semicolon, in lieu of
# tax <- tidyr::separate(tax, taxonomy, into = c("L1", "L2", "L3", "L4", "L5"), sep = ";")
n <- 1
for(i in strsplit(as.character(woFoodID$taxonomy), split=';')){
woFoodID[n, 'L1'] <<- i[[1]]
woFoodID[n, 'L2'] <<- i[[2]]
woFoodID[n, 'L3'] <<- i[[3]]
woFoodID[n, 'L4'] <<- i[[4]]
woFoodID[n, 'L5'] <<- i[[5]]
woFoodID[n, 'L6'] <<- i[[6]]
n <- n + 1
}
# remove Main.food.description column, because it's already made into row names.
woFoodID2 <<- woFoodID[, !colnames(woFoodID) == "Main.food.description"]
}
# Taxonomy - this is the taxonomy data from food tree code, but forced into a tabular format
tax <- read.delim("E:/MSU OneDrive 20210829/UMinn/Food_Tree-master/R/output/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and save as tax2.
PrepTax(data=tax)
length(mysplit)
lengths(mysplit[[]])
lengths(mysplit)
max(lengths(mysplit))
