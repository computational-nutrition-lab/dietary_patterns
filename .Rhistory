SubsetColumns <- function(data, start.col, end.col){
# Column Variables of "totals" dataframe.
colvars <- names(data)
# Get the first ID
start.col <- match(start.col, colvars)
# Get the second ID
end.col <- match(end.col, colvars)
# Subset range
subsetted <<- data[, start.col:end.col]
# Print what was loaded.
cat("'subsetted' contains the following", length(colnames(subsetted)), "columns.", "\n")
print(colnames(subsetted))
}
setwd("~/GitHub/dietary_patterns")
# Name your main directory for future use.
main.wd <- file.path(getwd())
# Import source code to run the analyses to follow.
source("lib/load_and_check.R")
source("lib/prep_data.R")
source("lib/PCA.R")
# ---------------------------------------------------------------------------------------------------------------
# Load example totals data
# Specify the directory where the data is.
SpecifyDataDirectory(directory.name = "eg_data/dietstudy/")
# Load the totals.csv
totals <- read.table("Totals_to_use.txt",  sep = "\t", header = T)
# Come back to the main directory
setwd(main.wd)
# Subset nutrients or food items data.
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Nutrients analysis  --> start.col = "PROT",    end.col = "B12_ADD"
SubsetColumns(data = totals, start.col = "PROT",    end.col = "B12_ADD")
# Food items analysis --> start.col = "F_TOTAL", end.col = "A_DRINKS"
SubsetColumns(data = totals, start.col = "F_TOTAL", end.col = "A_DRINKS")
# pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.5,
select.rep.fcn = 'mean', verbose = T)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# ---------------------------------------------------------------------------------------------------------------
# CLUSTER
# ClusterByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
# This is to be used in CollapseByCorrelation.
"ClusterByCorrelation" <- function(x, min.cor=0.75){
#     library('fastcluster')
cc <<- cor(x, use='pairwise.complete.obs', method='pear')
# if(ncol(x) == 379) browser()
cc <<- as.dist(1-cc)
hc <<- hclust(cc)
res <<- cutree(hc, h=1-min.cor)
names(res) <<- colnames(x)
return(res)
}
# COLLAPSE
# CollapseByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
#
# By default, chooses cluster reps as highest-variance member if select.rep.fcn=mean
"CollapseByCorrelation" <- function(x, min.cor=0.75,
select.rep.fcn=c('var','mean','lowest.mean',
'longest.name', 'shortest.name')[2],
verbose=FALSE){
if(verbose) cat('Clustering', ncol(x), 'features...')
gr <- ClusterByCorrelation(x, min.cor=min.cor)
if(verbose) cat('getting means...')
if(select.rep.fcn == 'mean'){
v <- apply(x,2,function(xx) mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'lowest.mean'){
v <- apply(x,2,function(xx) -mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'longest.name'){
v <- nchar(colnames(x))
} else if(select.rep.fcn == 'shortest.name'){
v <- -nchar(colnames(x))
} else {
v <- apply(x,2,function(xx) var(xx,use='complete.obs'))
}
if(verbose) cat('choosing reps...')
reps <- sapply(split(1:ncol(x),gr),function(xx) xx[which.max(v[xx])])
if(verbose)
cat(sprintf('collapsed from %d to %d.\n',ncol(x), length(reps)))
return(list(reps=reps, groups=gr))
}
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <-  subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variabels in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
head(subsetted_non0var, 1)      # original
head(selected_variables, 1)     # filtered
dim(cc)
length(cc)
head(cc)
dim(hc)
hc
is(cc)
cc
write.table(cc, "clipboard", sep = "\n")
mydf<-as.data.frame(as.matrix(cc))
write.csv(mydf, file = "results/mycc.csv")
# ---------------------------------------------------------------------------------------------------------------
# CLUSTER
# ClusterByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
# This is to be used in CollapseByCorrelation.
"ClusterByCorrelation" <- function(x, min.cor=0.75){
#     library('fastcluster')
distances <<- cor(x, use='pairwise.complete.obs', method='pear')
# if(ncol(x) == 379) browser()
cc <<- as.dist(1-distances)
hc <<- hclust(cc)
res <<- cutree(hc, h=1-min.cor)
names(res) <<- colnames(x)
return(res)
}
# COLLAPSE
# CollapseByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
#
# By default, chooses cluster reps as highest-variance member if select.rep.fcn=mean
"CollapseByCorrelation" <- function(x, min.cor=0.75,
select.rep.fcn=c('var','mean','lowest.mean',
'longest.name', 'shortest.name')[2],
verbose=FALSE){
if(verbose) cat('Clustering', ncol(x), 'features...')
gr <- ClusterByCorrelation(x, min.cor=min.cor)
if(verbose) cat('getting means...')
if(select.rep.fcn == 'mean'){
v <- apply(x,2,function(xx) mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'lowest.mean'){
v <- apply(x,2,function(xx) -mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'longest.name'){
v <- nchar(colnames(x))
} else if(select.rep.fcn == 'shortest.name'){
v <- -nchar(colnames(x))
} else {
v <- apply(x,2,function(xx) var(xx,use='complete.obs'))
}
if(verbose) cat('choosing reps...')
reps <- sapply(split(1:ncol(x),gr),function(xx) xx[which.max(v[xx])])
if(verbose)
cat(sprintf('collapsed from %d to %d.\n',ncol(x), length(reps)))
return(list(reps=reps, groups=gr))
}
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <-  subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variabels in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
head(subsetted_non0var, 1)      # original
head(selected_variables, 1)     # filtered
# ---------------------------------------------------------------------------------------------------------------
# Function to save the correlation matrix as a csv.
# The correlation matrix (cc) is produced by ClusterByCorrelation().
SaveCorrMatrix <- function(x=cc, name = "corr_matrix"){
write.csv(x, paste("results/", name, ".csv", sep = ""))
}
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc, name = "corr_matrix")
# ---------------------------------------------------------------------------------------------------------------
# Function to save the correlation matrix as a csv.
# The correlation matrix (cc) is produced by ClusterByCorrelation().
SaveCorrMatrix <- function(x=cc, name = "corr_matrix"){
write.csv(as.data.frame(as.matrix(x)), paste("results/", name, ".csv", sep = ""))
}
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc, name = "corr_matrix")
# ---------------------------------------------------------------------------------------------------------------
# CLUSTER
# ClusterByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
# This is to be used in CollapseByCorrelation.
"ClusterByCorrelation" <- function(x, min.cor=0.75){
#     library('fastcluster')
distances <<- cor(x, use='pairwise.complete.obs', method='pear')
# if(ncol(x) == 379) browser()
cc <<- as.dist(1-distances)
hc <<- hclust(cc)
res <<- cutree(hc, h=1-min.cor)
names(res) <<- colnames(x)
return(res)
}
# COLLAPSE
# CollapseByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
#
# By default, chooses cluster reps as highest-variance member if select.rep.fcn=mean
"CollapseByCorrelation" <- function(x, min.cor=0.75,
select.rep.fcn=c('var','mean','lowest.mean',
'longest.name', 'shortest.name')[2],
verbose=FALSE){
if(verbose) cat('Clustering', ncol(x), 'features...')
gr <- ClusterByCorrelation(x, min.cor=min.cor)
if(verbose) cat('getting means...')
if(select.rep.fcn == 'mean'){
v <- apply(x,2,function(xx) mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'lowest.mean'){
v <- apply(x,2,function(xx) -mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'longest.name'){
v <- nchar(colnames(x))
} else if(select.rep.fcn == 'shortest.name'){
v <- -nchar(colnames(x))
} else {
v <- apply(x,2,function(xx) var(xx,use='complete.obs'))
}
if(verbose) cat('choosing reps...')
reps <- sapply(split(1:ncol(x),gr),function(xx) xx[which.max(v[xx])])
if(verbose)
cat(sprintf('collapsed from %d to %d.\n',ncol(x), length(reps)))
return(list(reps=reps, groups=gr))
}
# ---------------------------------------------------------------------------------------------------------------
# Function to save the correlation matrix as a csv.
# The correlation matrix (cc) is produced by ClusterByCorrelation().
SaveCorrMatrix <- function(x=cc, name = "corr_matrix"){
write.csv(as.data.frame(as.matrix(x)), paste("results/", name, ".csv", sep = ""))
}
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <-  subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variabels in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
head(subsetted_non0var, 1)      # original
head(selected_variables, 1)     # filtered
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc, name = "corr_matrix")
cor(subsetted_non0var$F_TOTAL, subsetted_non0var$F_OTHER)
# ---------------------------------------------------------------------------------------------------------------
# CLUSTER
# ClusterByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
# This is to be used in CollapseByCorrelation.
"ClusterByCorrelation" <- function(x, min.cor=0.75){
#     library('fastcluster')
cc <<- cor(x, use='pairwise.complete.obs', method='pear')
# if(ncol(x) == 379) browser()
cc_1 <<- as.dist(1-cc)
hc <<- hclust(cc_1)
res <<- cutree(hc, h=1-min.cor)
names(res) <<- colnames(x)
return(res)
}
# COLLAPSE
# CollapseByCorrelation returns a vector of cluster ids for clusters with internal
# complete-linkage correlation of min.cor
#
# By default, chooses cluster reps as highest-variance member if select.rep.fcn=mean
"CollapseByCorrelation" <- function(x, min.cor=0.75,
select.rep.fcn=c('var','mean','lowest.mean',
'longest.name', 'shortest.name')[2],
verbose=FALSE){
if(verbose) cat('Clustering', ncol(x), 'features...')
gr <- ClusterByCorrelation(x, min.cor=min.cor)
if(verbose) cat('getting means...')
if(select.rep.fcn == 'mean'){
v <- apply(x,2,function(xx) mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'lowest.mean'){
v <- apply(x,2,function(xx) -mean(xx, na.rm=TRUE))
} else if(select.rep.fcn == 'longest.name'){
v <- nchar(colnames(x))
} else if(select.rep.fcn == 'shortest.name'){
v <- -nchar(colnames(x))
} else {
v <- apply(x,2,function(xx) var(xx,use='complete.obs'))
}
if(verbose) cat('choosing reps...')
reps <- sapply(split(1:ncol(x),gr),function(xx) xx[which.max(v[xx])])
if(verbose)
cat(sprintf('collapsed from %d to %d.\n',ncol(x), length(reps)))
return(list(reps=reps, groups=gr))
}
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <-  subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variabels in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
head(subsetted_non0var, 1)      # original
head(selected_variables, 1)     # filtered
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc, name = "corr_matrix")
cor(subsetted_non0var$F_TOTAL, subsetted_non0var$F_OTHER)
cor(subsetted_non0var$V_TOTAL, subsetted_non0var$V_DRKGR)
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
my_input <- selectedvar
source("lib/prep_data.R")
