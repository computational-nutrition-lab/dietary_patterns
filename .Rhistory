# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
#write.table(mycol, "clipboard", sep="\t")
head(mycol)
nrow(mycol)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
#write.table(mycol, "clipboard", sep="\t")
head(mycol)
nrow(mycol)
# Freq table with 2 variables.===========================================================
mydata = read.table(file="clipboard", sep="\t") # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
as.data.frame(table(mydata$V1))
V1table = as.data.frame(table(mydata$V1))
write.table(V1table, "clipboard", sep="\t")
write.table(V1table, "clipboard", sep="\t", row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
#write.table(mycol, "clipboard", sep="\t")
head(mycol)
nrow(mycol)
# mycol
bbb = as.data.frame(table(mycol))
bbb
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
#write.table(mycol, "clipboard", sep="\t")
head(mycol)
nrow(mycol)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
#write.table(mycol, "clipboard", sep="\t")
head(mycol)
nrow(mycol)
# mycol
bbb = as.data.frame(table(mycol))
bbb
write.table(bbb, "clipboard", sep="\t", row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
#write.table(mycol, "clipboard", sep="\t")
head(mycol)
nrow(mycol)
# mycol
bbb = as.data.frame(table(mycol))
# mycol
bbb = as.data.frame(table(mycol))
bbb
write.table(bbb, "clipboard", sep="\t", row.names = F)
#automatic install of packages if they are not installed already
list.of.packages <- c(
"foreach",
"doParallel",
"ranger",
"palmerpenguins",
"tidyverse",
"kableExtra"
)
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages) > 0){
install.packages(new.packages, dep=TRUE)
}
parallel::detectCores()
n.cores <- parallel::detectCores() - 1
#create the cluster
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
#check cluster definition (optional)
print(my.cluster)
#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
#check if it is registered (optional)
foreach::getDoParRegistered()
x <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
#loading packages
for(package.i in list.of.packages){
suppressPackageStartupMessages(
library(
package.i,
character.only = TRUE
)
)
}
#loading example data
data("penguins")
#check cluster definition (optional)
print(my.cluster)
#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
#check if it is registered (optional)
foreach::getDoParRegistered()
x <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
x
# Load the saved food items file.
Food_D1 <- read.table("eg_data/NHANES/Interview_IndFoods_Day1_DR1IFF_I_d.txt", sep="\t", header=T)
# Set where the NHANES data and food code table are.
# it is not in the eg_data folder because it's too large to save in GitHub folder.
# setwd("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16")
setwd("~/GitHub/dietary_patterns")
# Load necessary functions.
source("lib/load_clean_NHANES.R")
source("lib/prep_data_for_clustering.R")
# Load the saved food items file.
Food_D1 <- read.table("eg_data/NHANES/Interview_IndFoods_Day1_DR1IFF_I_d.txt", sep="\t", header=T)
# Add the food items information, too.
# Load FPED15-16.
FPED <- read.table("eg_data/NHANES/FPED/FPED_1516_forR.txt", sep="\t", header=T)
head(FPED, 1)
colnames(FPED)[1] <- "Food_code" # Important! Change the food code column name as Food_code.
dim(FPED)
pickedrow <- Food_D1[1, ]
# # food code of the selected row:
# selectedfoodcode <- pickedrow$Food_code
# Pick up a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedrow$Food_code, ]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- pickedrow[, "DR1IGRMS"] * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
head(pickedFPED)
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
Food_Cat <- cbind(pickedrow, cup_oz)
# Create a dataframe to save results; has the same ncol as Food_Cat.
result <- data.frame(matrix(NA, nrow=1000, ncol=ncol(Food_Cat)))
colnames(result) <- colnames(Food_Cat)
head(result)
# Put Food_Cat to the corresponding row.
result[1, ] <- Food_Cat[1, ]
#i=1 is done.
#i=2 and onwards -----------------------------------------------------------------
system.time(
for(i in 2:1000){
# Select only one row at a time.
pickedrow <- Food_D1[i, ]
pickedfoodcode <- pickedrow$Food_code
# Look for a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedfoodcode, ]
# GRMS
quantity <- pickedrow[, "DR1IGRMS"]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- quantity * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
tempnewrow <- cbind(pickedrow, cup_oz)
# Join the tempnewrow to the existing newrow.
# Food_Cat <<- rbind(Food_Cat, tempnewrow)
# Put Food_Cat to the corresponding row.
result[i, ] <- tempnewrow[1, ]
}
)
pickedrow <- Food_D1[1, ]
# # food code of the selected row:
# selectedfoodcode <- pickedrow$Food_code
# Pick up a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedrow$Food_code, ]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- pickedrow[, "DR1IGRMS"] * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
head(pickedFPED)
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
Food_Cat <- cbind(pickedrow, cup_oz)
# Create a dataframe to save results; has the same ncol as Food_Cat.
result <- data.frame(matrix(NA, nrow=1000, ncol=ncol(Food_Cat)))
colnames(result) <- colnames(Food_Cat)
head(result)
# Put Food_Cat to the corresponding row.
result[1, ] <- Food_Cat[1, ]
#i=1 is done.
system.time(
foreach(
i = 1:1000,
.combine = 'c'
) %dopar% {
# Select only one row at a time.
pickedrow <- Food_D1[i, ]
pickedfoodcode <- pickedrow$Food_code
# Look for a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedfoodcode, ]
# GRMS
quantity <- pickedrow[, "DR1IGRMS"]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- quantity * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
tempnewrow <- cbind(pickedrow, cup_oz)
# Join the tempnewrow to the existing newrow.
# Food_Cat <<- rbind(Food_Cat, tempnewrow)
# Put Food_Cat to the corresponding row.
result[i, ] <- tempnewrow[1, ]
}
)
# Create the first row then do loop for the rest. ==============================================================================
# i=1 ----------------------------------------------------------------------------
# Select only one row at a time.
pickedrow <- Food_D1[1, ]
# Pick up a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedrow$Food_code, ]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- pickedrow[, "DR1IGRMS"] * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
head(pickedFPED)
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
Food_Cat <- cbind(pickedrow, cup_oz)
# Create a dataframe to save results; has the same ncol as Food_Cat.
result <- data.frame(matrix(NA, nrow=10000, ncol=ncol(Food_Cat)))
colnames(result) <- colnames(Food_Cat)
head(result)
# Put Food_Cat to the corresponding row.
result[1, ] <- Food_Cat[1, ]
print(Food_Cat)
#i=2 and onwards -----------------------------------------------------------------
system.time(
for(i in 2:10000){
# Select only one row at a time.
pickedrow <- Food_D1[i, ]
pickedfoodcode <- pickedrow$Food_code
# Look for a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedfoodcode, ]
# GRMS
quantity <- pickedrow[, "DR1IGRMS"]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- quantity * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
tempnewrow <- cbind(pickedrow, cup_oz)
# Join the tempnewrow to the existing newrow.
# Food_Cat <<- rbind(Food_Cat, tempnewrow)
# Put Food_Cat to the corresponding row.
result[i, ] <- tempnewrow[1, ]
}
)
pickedrow <- Food_D1[1, ]
# # food code of the selected row:
# selectedfoodcode <- pickedrow$Food_code
# Pick up a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedrow$Food_code, ]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- pickedrow[, "DR1IGRMS"] * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
head(pickedFPED)
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
Food_Cat <- cbind(pickedrow, cup_oz)
# Create a dataframe to save results; has the same ncol as Food_Cat.
result <- data.frame(matrix(NA, nrow=10000, ncol=ncol(Food_Cat)))
colnames(result) <- colnames(Food_Cat)
head(result)
# Put Food_Cat to the corresponding row.
result[1, ] <- Food_Cat[1, ]
#i=1 is done.
system.time(
foreach(
i = 1:10000,
.combine = 'c'
) %dopar% {
# Select only one row at a time.
pickedrow <- Food_D1[i, ]
pickedfoodcode <- pickedrow$Food_code
# Look for a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedfoodcode, ]
# GRMS
quantity <- pickedrow[, "DR1IGRMS"]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- quantity * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
tempnewrow <- cbind(pickedrow, cup_oz)
# Join the tempnewrow to the existing newrow.
# Food_Cat <<- rbind(Food_Cat, tempnewrow)
# Put Food_Cat to the corresponding row.
result[i, ] <- tempnewrow[1, ]
}
)
# Finally, it is always recommendable to stop the cluster when we are done working with it.
parallel::stopCluster(cl = my.cluster)
pickedrow <- Food_D1[1, ]
# # food code of the selected row:
# selectedfoodcode <- pickedrow$Food_code
# Pick up a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedrow$Food_code, ]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- pickedrow[, "DR1IGRMS"] * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
head(pickedFPED)
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
Food_Cat <- cbind(pickedrow, cup_oz)
# Create a dataframe to save results; has the same ncol as Food_Cat.
result <- data.frame(matrix(NA, nrow=10000, ncol=ncol(Food_Cat)))
colnames(result) <- colnames(Food_Cat)
head(result)
# Put Food_Cat to the corresponding row.
result[1, ] <- Food_Cat[1, ]
#i=1 is done.
system.time(
foreach(
i = 1:10000,
.combine = 'c'
) %dopar% {
# Select only one row at a time.
pickedrow <- Food_D1[i, ]
pickedfoodcode <- pickedrow$Food_code
# Look for a row in FPED that contains the food_code in pickedrow.
pickedFPED <- FPED[FPED$Food_code == pickedfoodcode, ]
# GRMS
quantity <- pickedrow[, "DR1IGRMS"]
# GRMS x each food category --> cup or servings of that food in that particular amount.
cup_oz <- quantity * pickedFPED[, -1]/100  # "-1" is to exclude food_code from multiplication.
# Join pickedrow and cup_oz, which is the categorized food items converted to cup or oz.
tempnewrow <- cbind(pickedrow, cup_oz)
# Join the tempnewrow to the existing newrow.
# Food_Cat <<- rbind(Food_Cat, tempnewrow)
# Put Food_Cat to the corresponding row.
result[i, ] <- tempnewrow[1, ]
}
)
