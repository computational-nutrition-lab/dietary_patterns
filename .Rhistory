panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 1), hjust=1.1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0), hjust=1.1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
n.PCx
aaa$Variables
nchar(aaa$Variables)
is(aaa$Variables)
barplot(x=aaa$Variables, y=aaa$Ytoplot)
plot(x=aaa$Variables, y=aaa$Ytoplot)
ggplot(aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity")
n.PCx
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=1), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=1), position=position_dodge(width = 0.5), hjust=0, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=0), position=position_dodge(width = 0.5), hjust=0, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=-0.01), position=position_dodge(width = 0.5), hjust=0, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=-0.01), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=-0.01), position=position_dodge(width = 0.5), hjust=1, angle=90)+
geom_text(aes(label=Variables, y= n.PCx), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity" )+ #, fill=c.PCx) +
theme_bw() +
# labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x =  element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
# geom_text(aes(label=Variables, y=-0.01), position=position_dodge(width = 0.5), hjust=1, angle=90)+
geom_text(aes(label=Variables, y= n.PCx), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
# ---------------------------------------------------------------------------------------------------------------
# Plot the contribution of each variable to PC1.
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", sort.variables=c(TRUE, FALSE)){
# Save the rotation (contribution of the Variables to each PC) as a dataframe.
Rota <- pca.result[["rotation"]]
Rotadf = as.data.frame(Rota)
# Make a column that contains the variable names (rownames).
Rotadf$Variables <- rownames(Rotadf)
# IF keeping the original order of the Variables --------------------------------------------
if(sort.variables==FALSE){
# Select the Variables and only the specified PC to plot.
aaa <- data.frame(Variables=Rotadf$Variables, Ytoplot= Rotadf[, whichPC])
# Make Variables as an ordered factor (the order of levels will be preserved).
aaa$Variables <- factor(aaa$Variables, levels=aaa$Variables)
# Calculate the position at which labels are placed for each bar.
n.PCx <- ifelse(aaa[, "Ytoplot"] > 0, yes= -0.01, no= aaa[, "Ytoplot"]-0.01)
# Assign each value a positive color and negative color.
c.PCx <- ifelse(aaa[, "Ytoplot"] > 0, yes=positive.color, no=negative.color)
# Make a plot with the original order of Variables.
loadings_plot <<- ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity", fill=c.PCx) +
theme_bw() +
labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
# IF sorting the Variables by their contributions ---------------------------------------
}else if(sort.variables==TRUE){
# Select the Variables and only the specified PC to plot.
bbb <- data.frame(Variables=Rotadf$Variables, Ytoplot= Rotadf[, whichPC])
# Sort the Variables in the order of Y (the contribution to the specified PC.)
bbb_s <- bbb[ order(bbb$Ytoplot, decreasing=T),  ]
# Make Variables as an ordered factor.
bbb_s$Variables <- factor(bbb_s$Variables, levels=bbb_s$Variables)
# Calculate the position at which labels are placed for each bar.
n.PCx <- ifelse(bbb_s[, "Ytoplot"] > 0, yes= -0.01, no= bbb_s[, "Ytoplot"]-0.01)
# Assign each value a positive color and negative color.
c.PCx <- ifelse(bbb_s[, "Ytoplot"] > 0, yes=positive.color, no=negative.color)
# Make a plot with the original order of the Variables.
loadings_plot <<- ggplot(data= bbb_s, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat='identity', fill=c.PCx) +
theme_bw() +
labs(y=paste0(whichPC)) +
theme(axis.ticks.x = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
}
}
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/NHANES1516_totalsbyhand_FC_n100/NHANES1516_total_d12_FC_mean_QC_2_100sampled_loadings_PC1.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/NHANES1516_totalsbyhand_FC_n100/NHANES1516_total_d12_FC_mean_QC_2_100sampled_loadings_PC2.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# ---------------------------------------------------------------------------------------------------------------
# Plot the contribution of each variable to PC1.
LoadingsPlot <- function(pca.result,  whichPC, positive.color="green2", negative.color="grey70", sort.variables=c(TRUE, FALSE)){
# Save the rotation (contribution of the Variables to each PC) as a dataframe.
Rota <- pca.result[["rotation"]]
Rotadf = as.data.frame(Rota)
# Make a column that contains the variable names (rownames).
Rotadf$Variables <- rownames(Rotadf)
# IF keeping the original order of the Variables --------------------------------------------
if(sort.variables==FALSE){
# Select the Variables and only the specified PC to plot.
aaa <- data.frame(Variables=Rotadf$Variables, Ytoplot= Rotadf[, whichPC])
# Make Variables as an ordered factor (the order of levels will be preserved).
aaa$Variables <- factor(aaa$Variables, levels=aaa$Variables)
# Calculate the position at which labels are placed for each bar.
n.PCx <- ifelse(aaa[, "Ytoplot"] > 0, yes= -0.01, no= aaa[, "Ytoplot"]-0.01)
# Assign each value a positive color and negative color.
c.PCx <- ifelse(aaa[, "Ytoplot"] > 0, yes=positive.color, no=negative.color)
# Make a plot with the original order of Variables.
loadings_plot <<- ggplot(data= aaa, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat="identity", fill=c.PCx) +
theme_bw() +
labs(y=paste0(whichPC)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1) ) + # to check if the variable orders are correct.
theme(axis.ticks.x = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
# geom_text(aes(label=Variables), position=position_dodge(width = 0.5), hjust=1.1, angle=90)+
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
# IF sorting the Variables by their contributions ---------------------------------------
}else if(sort.variables==TRUE){
# Select the Variables and only the specified PC to plot.
bbb <- data.frame(Variables=Rotadf$Variables, Ytoplot= Rotadf[, whichPC])
# Sort the Variables in the order of Y (the contribution to the specified PC.)
bbb_s <- bbb[ order(bbb$Ytoplot, decreasing=T),  ]
# Make Variables as an ordered factor.
bbb_s$Variables <- factor(bbb_s$Variables, levels=bbb_s$Variables)
# Calculate the position at which labels are placed for each bar.
n.PCx <- ifelse(bbb_s[, "Ytoplot"] > 0, yes= -0.01, no= bbb_s[, "Ytoplot"]-0.01)
# Assign each value a positive color and negative color.
c.PCx <- ifelse(bbb_s[, "Ytoplot"] > 0, yes=positive.color, no=negative.color)
# Make a plot with the original order of the Variables.
loadings_plot <<- ggplot(data= bbb_s, aes(x=Variables, y=Ytoplot)) +
geom_bar(stat='identity', fill=c.PCx) +
theme_bw() +
labs(y=paste0(whichPC)) +
theme(axis.ticks.x = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title.x = element_text(margin=margin(t = 10, r = 0, b = 0, l = 0) ),
axis.title.y = element_text(margin=margin(t = 0, r = 10, b = 0, l = 0) ) ) +
geom_text(aes(label=Variables, y=n.PCx), position=position_dodge(width = 0.5), hjust=1, angle=90)+
scale_y_continuous(expand = expansion(mult=c(0.5, 0.1))) # give 0.5 space at the lower limit of Y (to fit text).
}
}
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
source("lib/k-means.R")
source("lib/prep_data.R")
# ---------------------------------------------------------------------------------------------------------------
# Define your input file. Need to scale it to accommodate measurements in different units.
colnames(selected_variables)
kmeans_input <- scale(selected_variables) # correlated variables removed.
# Set your ggplot2 theme.
require(ggplot2)
theme_set(theme_bw(base_size = 14))
# ---------------------------------------------------------------------------------------------------------------
# Use the elbow method to find the ideal K.
ElbowMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the elbow method to find the ideal K.
ElbowMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# ---------------------------------------------------------------------------------------------------------------
# Use the Gap statistic method to find the ideal K.
set.seed(123)
GapMethod(k.values = 1:15)
GapMethod(k.values = 1:15)
FactoextraGapMethod(k.values = 1:15)
FactoextraGapMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with multiple (2-4) Ks, and plot them in one window.
MultipleK(myKs = c(2,3,4,5))
# Load the necessary functions
source("lib/prep_data_for_clustering.R")
source("lib/PCA.R")
source("lib/k-means.R")
# Load the subsetted totals file.
totals_QCed_sampled <- read.table(        "eg_data/NHANES/NHANES1516_total_d12_FC_mean_QC_2_100sampled.txt", sep="\t", header=T)
# Define which columns to drop.
drops <- c("KCAL","GRMS", "MOIS", "NoOfItems")
# Take only the columns whose names are NOT in the drop vector.
aaa <- totals_QCed_sampled[ , !(names(totals_QCed_sampled) %in% drops)]
# Save it as totals_QCed_sampled.
totals_QCed_sampled <- aaa
colnames(totals_QCed_sampled)
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Nutrients
SubsetColumns(data=input_data, start.col="PROT", end.col="P226")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"results/PCA_results/NHANES1516_totalsbyhand_FC_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_rv.txt",
sep="\t", row.names=F, quote=F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn = "results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_corr_mat.txt")
# ========================================================================================
# Perform Principal Component Analysis.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Name your input data.
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- selected_variables
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Create a scree plot.
screep <- LineScreePlot(pca.data = pca_input, pca.result = scaled_pca)
screep
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_scree.pdf", screep, device="pdf", width=5, height=5, units="in")
# Create a biplot.
# A biplot with the individuals as black dots and variables labelled.
biplotdots <- BiplotDots(pca.result = scaled_pca, pca.data = pca_input, alpha = 0.5)
biplotdots
# A biplot with the individuals labeled.
biplotlabeled <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label = T)
biplotlabeled
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_biplotlabeled.pdf", biplotlabeled, device="pdf", width=5, height=5, units="in")
# A biplot with the individuals labeled without the variables' arrows.
biplotlabeledwoarrows <- BiplotLabeledwoArrows(pca.result=scaled_pca, pca.data=pca_input,
individuals.label=T)
biplotlabeledwoarrows #+coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
biplotlabeledwoarrows #+coord_cartesian(xlim=c(-0.1, 0.1), ylim=c(0.05, 0.1))
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_biplotlabeledwoarrows.pdf", biplotlabeledwoarrows, device="pdf", width=5, height=5, units="in")
# Plot the directions of the variables.
directions <- BiplotLabeled(pca.result=scaled_pca, pca.data=pca_input, individuals.label=F)
directions
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_directions.pdf", directions, device="pdf", width=5, height=5, units="in")
# Plot the contribution of the variables to a given PC.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
# Plot the contribution of the variables to a given PC: PC2 here.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
# Plot the contribution of the variables to a given PC: PC1 here.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_loadings_PC1.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# Plot the contribution of the variables to a given PC: PC2 here.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_loadings_PC1.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# Plot the contribution of the variables to a given PC: PC1 here.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC1",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_loadings_PC1.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# Plot the contribution of the variables to a given PC: PC2 here.
LoadingsPlot(pca.result=scaled_pca,  whichPC="PC2",
positive.color="green2", negative.color="grey70", sort.variables = T)
loadings_plot
ggsave("results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_loadings_PC2.pdf", loadings_plot, device="pdf", width=8, height=4.8, units="in")
# ---------------------------------------------------------------------------------------------------------------
# Save the variance explained by each PC as a .txt file.
# Change the file name as necessary.
SaveVarExplained(pca.data = pca_input, pca.result = scaled_pca,
out.fn = "results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_PC_var_explained.txt")
# ---------------------------------------------------------------------------------------------------------------
# Calculate loadings of each PC to the variables and
# save it as a txt file in the results folder.
# Change the file name as necessary.
SaveLoadings(pca.result=scaled_pca,
out.fn="results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_PC_loadings.txt")
# ---------------------------------------------------------------------------------------------------------------
# Save the PC values with the input which has the metadata and food codes, food names.
# Input is your food input file before any prep for clustering, from which you derived the input for the PCA.
SaveInputAndPCs(input = "eg_data/NHANES/NHANES1516_total_d12_FC_mean_QC_2_100sampled.txt",
pca.results = scaled_pca,
out.fn = "results/PCA_results/NHANES1516_totalsbyhand_nut_n100/NHANES1516_total_d12_nut_mean_QC_2_100sampled_input_PCs.txt")
# ---------------------------------------------------------------------------------------------------------------
# Define your input file. Need to scale it to accommodate measurements in different units.
colnames(selected_variables)
kmeans_input <- scale(selected_variables) # correlated variables removed.
# Set your ggplot2 theme.
require(ggplot2)
theme_set(theme_bw(base_size = 14))
# ---------------------------------------------------------------------------------------------------------------
# Use the elbow method to find the ideal K.
ElbowMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K.  Uses cluster package.
SilhouetteMethod(k.values = 2:15)
# or use the factoextra package to use the Silhouette method.
factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
# ---------------------------------------------------------------------------------------------------------------
# Use the Gap statistic method to find the ideal K.
set.seed(123)
GapMethod(k.values = 1:15)
GapMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with multiple (2-4) Ks, and plot them in one window.
MultipleK(myKs = c(2,3,4,5))
parallel::detectCores()
n.cores <- parallel::detectCores() - 1
#create the cluster
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
#check cluster definition (optional)
print(my.cluster)
#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
install.packages(DoParallel)
install.packages('DoParallel')
install.packages('doParallel')
#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
#check if it is registered (optional)
foreach::getDoParRegistered()
x <- foreach(
i = 1:10,
.combine = 'c'
) %dopar% {
sqrt(i)
}
install.packages('foreach')
#automatic install of packages if they are not installed already
list.of.packages <- c(
"foreach",
"doParallel",
"ranger",
"palmerpenguins",
"tidyverse",
"kableExtra"
)
