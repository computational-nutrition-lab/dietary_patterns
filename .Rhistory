setwd(../)
setwd('../')
# Name your main directory for future use.
main.wd <- file.path(getwd())
# load the necessary packages.
library(phyloseq)
library(ggtree)
library(ggplot2)
###### RESUME FROM HERE #######
UnweightedUnifracDis <- function(input.phyloseq.obj = phyfoods, output.name){
unweighted_uni_dis1 <- as.matrix(phyloseq::distance(phyfoods, method="unifrac"))
unweighted_uni_dis2 <- as.data.frame(unweighted_uni_dis1)
unweighted_uni_dis3 <- data.frame("Sample" = rownames(unweighted_uni_dis2), unweighted_uni_dis2)
write.table(x = unweighted_uni_dis3,
file = output.fn, sep="\t", row.names = F)
}
# Food
# Load food OTU table - this is our food OTU data
food <- read.delim("~/GitHub/dietary_patterns/results/Food_tree_results/mct.reduced_4Lv.dhydrt.otu.txt", row.names = 1)
# Format the food file and create a otu_table called OTU.
PrepFood(data=food)
# Load the necessary scripts.
source("lib/unifrac_ordination.R")
# Format the food file and create a otu_table called OTU.
PrepFood(data=food)
# Taxonomy (tax)
tax <- read.delim("~/GitHub/dietary_patterns/results/Food_tree_results/mct.reduced_4Lv.taxonomy.txt")
# Format the tax file and create a taxonomy table called TAX.
PrepTax(data=tax)
# Sample
meta <- read.csv( "~/GitHub/dietary_patterns/eg_data/dietstudy/food_map_txt_Metadata_2.csv",
row.names = 1, check.names = F)
# Format the metafile and save it as 'SAMPLES'.
PrepMeta(data=meta)
# Food tree
foodtree <- read_tree("~/GitHub/dietary_patterns/results/Food_tree_results/mct.reduced_4Lv.tree.nwk")
# It is OK to see a message saying that
# "Found more than one class "phylo" in cache; using the first, from namespace 'phyloseq'
# Also defined by 'tidytree'"
# Format food tree and save it as 'TREE'.
PrepTree(data=foodtree)
# ---------------------------------------------------------------------------------------------------------------
# Make a phyloseq object with OTU, TAX, samples, and foodtree.
phyfoods <- phyloseq(OTU, TAX, SAMPLES, TREE)
UnweightedUnifracDis(input.phyloseq.obj = phyfoods, output.name = "results/unweighted_uni_dis.txt")
###### RESUME FROM HERE #######
UnweightedUnifracDis <- function(input.phyloseq.obj = phyfoods, output.fn){
unweighted_uni_dis1 <- as.matrix(phyloseq::distance(phyfoods, method="unifrac"))
unweighted_uni_dis2 <- as.data.frame(unweighted_uni_dis1)
unweighted_uni_dis3 <- data.frame("Sample" = rownames(unweighted_uni_dis2), unweighted_uni_dis2)
write.table(x = unweighted_uni_dis3,
file = output.fn, sep="\t", row.names = F)
}
UnweightedUnifracDis(input.phyloseq.obj = phyfoods, output.fn = "results/unweighted_uni_dis.txt")
WeightedUnifracDis <- function(input.phyloseq.obj = phyfoods, output.fn){
# Calculate unweighted unifrac distance and save as a matrix.
weighted_uni_dis1 <- as.matrix(phyloseq::distance(phyfoods, method="wunifrac"))
# Convert it to a data frame. (to edit rownames)
weighted_uni_dis2 <- as.data.frame(weighted_uni_dis1)
# Create a new column with a columnname of "Sample" and put rownames (UserName) on that column
weighted_uni_dis3 <- data.frame("Sample" = rownames(weighted_uni_dis2), weighted_uni_dis2)
# Save as a txt file.
write.table(x = weighted_uni_dis3, file = output.fn, sep="\t", row.names = F)
}
# Generate and save an unweighted unifrac distance matrix for use outside R.  type="samples" only.
WeightedUnifracDis(input.phyloseq.obj = phyfoods, output.fn = "results/WEIGHTED_uni_dis.txt")
MergeAxesAndMetadata <- function(ord.object, number.of.axes=4, meta.data = meta, output.fn){
# extract all the Axis vectors
allvectors <- as.data.frame(ord.object["vectors"])
# extract Axes 1 through the specified axis
vectors <- allvectors[, 1:number.of.axes]
# make rownames as a column for merging.
meta_usersdf <<- merge(x=meta.data, y=vectors, all.x=T, by="row.names")
# Save as a txt file.
write.table(x = meta_usersdf, file = output.fn, sep="\t", row.names = F)
}
# Perform Principal Coordinate Analysis (PCoA) with weighted unifrac distance of your food data.
# This may take a few minutes depending on your data size.
# e.g. a large phyloseq object (7.9 MB) takes ~ 1 min.
ordinated <- phyloseq::ordinate(phyfoods, method="PCoA", distance="unifrac", weighted=T)
# Extract the Axes values of Users each day.
usersdf <- as.data.frame(ordinated$vectors)
MergeAxesAndMetadata <- function(ord.object, number.of.axes, meta.data, output.fn){
# extract all the Axis vectors
allvectors <- as.data.frame(ord.object["vectors"])
# extract Axes 1 through the specified axis
vectors <- allvectors[, 1:number.of.axes]
# make rownames as a column for merging.
meta_usersdf <<- merge(x=meta.data, y=vectors, all.x=T, by="row.names")
# Save as a txt file.
write.table(x = meta_usersdf, file = output.fn, sep="\t", row.names = F)
}
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data = meta, output.fn= "results/meta_users_fn.txt")
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
scale_color_manual(values = distinct100colors) +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
# Save the percent variance explained for the fist 10 axes.
eigen_percent <- head(ordinated$values$Relative_eig, 10)
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
# Define ggplot2 arguments and themes first.
theme_set(theme_bw())
fontsize = 18L
theme_update(axis.title.x = element_text(size=fontsize))
theme_update(axis.title.y = element_text(size=fontsize))
theme_update(plot.title   = element_text(size=fontsize+2))
mytheme <- theme_bw(base_size = 18) +
theme(axis.title.x=element_text(margin=margin(t = 10, r = 0, b = 0, l = 0))) +
theme(axis.title.y=element_text(margin=margin(t = 0, r = 10, b = 0, l = 0))) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
theme(aspect.ratio = 1)
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
p1
?merge
MergeAxesAndMetadata <- function(ord.object, number.of.axes, meta.data, output.fn){
# extract all the Axis vectors
allvectors <- as.data.frame(ord.object["vectors"])
# extract Axes 1 through the specified axis
vectors <- allvectors[, 1:number.of.axes]
# make rownames as a column for merging.
meta_usersdf <<- merge(x=meta.data, y=vectors, all.x=T, by="row.names", sort=FALSE)
# Save as a txt file.
write.table(x = meta_usersdf, file = output.fn, sep="\t", row.names = F)
}
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data = meta, output.fn= "results/meta_users_nosort.txt")
head(phyfoods["vetctors"])
phyfoods["vetctors"]
head(as.data.frame(phyfoods["vetctors"]))
aaa = as.data.frame(phyfoods["vetctors"])
View(phyfoods)
head(as.data.frame(ordinated["vectors"]))
View(ordinated)
colnames(ordinated[["vectors"]])
head(ordinated[["vectors"]], 1)
aaa = as.data.frame(ordinated[["vectors"]])
head(aaa)
MergeAxesAndMetadata <- function(ord.object, number.of.axes, meta.data, output.fn){
# extract all the Axis vectors
allvectors <<- as.data.frame(ord.object["vectors"])
# extract Axes 1 through the specified axis
vectors <<- allvectors[, 1:number.of.axes]
# make rownames as a column for merging.
meta_usersdf <<- merge(x=meta.data, y=vectors, all.x=T, by="row.names", sort=FALSE)
# Save as a txt file.
write.table(x = meta_usersdf, file = output.fn, sep="\t", row.names = F)
}
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data = meta, output.fn= "results/meta_users_nosort.txt")
head(vectors)
head(allvectors)
allvectorsbyhand <<- as.data.frame(ordinated["vectors"])
head(allvectorsbyhand)
sub(pattern='vectors.', replacement='', x=colnames(allvectors))
length(colnames(allvectors))
head(colnames(allvectors))
sub(pattern='vectors.', replacement='', x=colnames(allvectors))
MergeAxesAndMetadata <- function(ord.object, number.of.axes, meta.data, output.fn){
# extract all the Axis vectors
allvectors <<- as.data.frame(ord.object["vectors"])
# Remove the suffix 'vectors.' in the column names of 'allvectors'
colnames(allvectors) <- sub(pattern='vectors.', replacement='', x=colnames(allvectors))
# extract Axes 1 through the specified axis
vectors <<- allvectors[, 1:number.of.axes]
# make rownames as a column for merging.
meta_usersdf <<- merge(x=meta.data, y=vectors, all.x=T, by="row.names", sort=FALSE)
# Save as a txt file.
write.table(x = meta_usersdf, file = output.fn, sep="\t", row.names = F)
}
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data= meta, output.fn= "results/meta_users_af.txt")
head(allvectors)
View(allvectors)
View(allvectorsbyhand)
MergeAxesAndMetadata <- function(ord.object, number.of.axes, meta.data, output.fn){
# extract all the Axis vectors
allvectors <<- as.data.frame(ord.object["vectors"])
# Remove the suffix 'vectors.' in the column names of 'allvectors'
colnames(allvectors) <<- sub(pattern='vectors.', replacement='', x=colnames(allvectors))
# extract Axes 1 through the specified axis
vectors <<- allvectors[, 1:number.of.axes]
# make rownames as a column for merging.
meta_usersdf <<- merge(x=meta.data, y=vectors, all.x=T, by="row.names", sort=FALSE)
# Save as a txt file.
write.table(x = meta_usersdf, file = output.fn, sep="\t", row.names = F)
}
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data= meta, output.fn= "results/meta_users_af.txt")
head(vectors)
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data= meta, output.fn= "results/meta_users.txt")
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
p1
mytheme <- theme_bw(base_size = 16) +
theme(axis.title.x=element_text(margin=margin(t = 10, r = 0, b = 0, l = 0))) +
theme(axis.title.y=element_text(margin=margin(t = 0, r = 10, b = 0, l = 0))) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
theme(aspect.ratio = 1)
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
p1
# Load the distinct 100 colors for use.
distinct100colors <- readRDS("~/GitHub/R_Toolbox/distinct100colors.rda")
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
scale_color_manual(values = distinct100colors) + # OR use viridis theme.
scale_color_viridis_c() +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) + # OR use viridis theme.
scale_color_viridis_c() +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
p1
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
# scale_color_manual(values = distinct100colors) + # OR use viridis theme.
scale_color_viridis_d() +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
p1
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
scale_color_manual(values = distinct100colors) + # OR use viridis theme.
# scale_color_viridis_d() +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
mytheme
p1
# Add ellipses at a desired confidence level.
p1 + stat_ellipse(level=0.95)
# Add lines to connect samples in order of the variable on the x axis.
p1 + geom_line(aes(color = UserName))
# Add lines to connect samples in the order in which they appear in the data.
p1 + geom_path(aes(color = UserName))
# make a polygon by UserName
p1 + geom_polygon(aes(fill = UserName)) + geom_point(aes(color=UserName), size=3) +
scale_fill_manual(values=distinct100colors)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight one sample with others being grey.
select_point_1 <- subset(meta_usersdf, UserName=="MCTs11")
p1 + geom_point(size=2, color="grey") +
geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight multiple samples with others being grey.
select_points <- subset(p2df, UserName=="MCTs11" | UserName=="MCTs12" )
# Save an ordination plot for filtering purposes.
p1df = plot_ordination(phyfoods, ordinated, type="samples", color="UserName", justDF=T)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight multiple samples with others being grey.
select_points <- subset(p1df, UserName=="MCTs11" | UserName=="MCTs12" )
p1 + geom_point(data=select_points, aes(x=Axis.1, y=Axis.2, color=as.factor(UserName))) +
scale_color_manual(values = c("MCTs11"="red", "MCTs12"="blue"))
View(p1)
View(p1df)
rm(p1df)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight one sample; other points will retain their original colors.
select_point_1 <- subset(meta_usersdf, UserName=="MCTs11")
# Changing the shape sizes might help find the dots. Note that points may be overlapping
p1 + geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=4)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight multiple samples; other points will retain their original colors.
select_point_1 <- subset(meta_usersdf, UserName=="MCTs11")
select_point_2 <- subset(meta_usersdf, UserName=="MCTs12")
p1 + geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=4) +
geom_point(data=select_point_2, aes(x=Axis.1, y=Axis.2), color="green", size=4)
p1 + geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=4) +
geom_point(data=select_point_2, aes(x=Axis.1, y=Axis.2), color="green", size=4)
eigen_percent <- ordinated$values$Relative_eig
head(eigen_percent)
length(eigen_percent)
data.frame(Axis=1:length(eigen_percent), Eigen=eigen_percent)
write.table(x=eigen_percentdf, file="results/eigen_percent.txt", sep="\t", row.names=F)
eigen_percentdf <- data.frame(Axis=1:length(eigen_percent), Eigen=eigen_percent)
write.table(x=eigen_percentdf, file="results/eigen_percent.txt", sep="\t", row.names=F)
# Save the percent variance explained as a txt file.
Eigen <- function(eigen.input = eigen_percent, output.fn){
eigen_percentdf <- data.frame(Axis=1:length(eigen.input), Eigen= eigen.input)
write.table(x=eigen_percentdf, file= output.fn, sep="\t", row.names=F)
}
Eigen(eigen.input = eigen_percent, output.fn="results/eigen_pc_fn.txt")
# Load the necessary scripts.
source("lib/unifrac_ordination.R")
# Define ggplot2 arguments and themes first.
theme1 <- theme_bw(base_size = 16) +
theme(axis.title.x=element_text(margin=margin(t = 10, r = 0, b = 0, l = 0))) +
theme(axis.title.y=element_text(margin=margin(t = 0, r = 10, b = 0, l = 0))) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
theme(aspect.ratio = 1)
# Load the distinct 100 colors for use.
distinct100colors <- readRDS("~/GitHub/R_Toolbox/distinct100colors.rda")
food <- read.delim("~/GitHub/dietary_patterns/results/Food_tree_results/mct.reduced_1Lv.dhydrt.otu.txt", row.names = 1)
tax <- read.delim("~/GitHub/dietary_patterns/results/Food_tree_results/mct.reduced_1Lv.taxonomy.txt")
# Format the food file and create a otu_table called OTU.
PrepFood(data=food)
# Format the tax file and create a taxonomy table called TAX.
PrepTax(data=tax)
# Sample
meta <- read.csv( "~/GitHub/dietary_patterns/eg_data/dietstudy/food_map_txt_Metadata_2.csv",
row.names = 1, check.names = F)
# Format the metafile and save it as 'SAMPLES'.
PrepMeta(data=meta)
foodtree <- read_tree("~/GitHub/dietary_patterns/results/Food_tree_results/mct.reduced_1Lv.tree.nwk")
# It is OK to see a message saying that
# "Found more than one class "phylo" in cache; using the first, from namespace 'phyloseq'
# Also defined by 'tidytree'"
# Format food tree and save it as 'TREE'.
PrepTree(data=foodtree)
# ---------------------------------------------------------------------------------------------------------------
# Make a phyloseq object with OTU, TAX, samples, and foodtree.
phyfoods <- phyloseq(OTU, TAX, SAMPLES, TREE)
# Check the level 1 foods in your food tree
L1s = tax_table(phyfoods)[, "L1"]
as.vector(unique(L1s))
# Perform Principal Coordinate Analysis (PCoA) with weighted unifrac distance of your food data.
# This may take a few minutes depending on your data size.
# e.g. a large phyloseq object (7.9 MB) takes ~ 1 min.
ordinated <- phyloseq::ordinate(phyfoods, method="PCoA", distance="unifrac", weighted=T)
# If it gives a warning with Lv1 saying that:
# In matrix(tree$edge[order(tree$edge[, 1]), ][, 2], byrow = TRUE,  :
#             data length [1461] is not a sub-multiple or multiple of the number of rows [731]
# A solution shared in GitHub discussion forum is to transform all multichotomies into dichotomies with
# branches with length zero: need the age package.
# (https://github.com/joey711/phyloseq/issues/936, see commnet by PandengWang on Dec 26, 2019)
new_tre <- ape::multi2di(foodtree)
# Prep it again for making a unifrac object.
PrepTree(data=new_tre)
# With the newly created TREE, create a phyloseq object once again.
phyfoods <- phyloseq(OTU, TAX, SAMPLES, TREE)
# Perform Principal Coordinate Analysis (PCoA) with weighted unifrac distance of your food data.
# This may take a few minutes depending on your data size.
# e.g. a large phyloseq object (7.9 MB) takes ~ 1 min.
ordinated <- phyloseq::ordinate(phyfoods, method="PCoA", distance="unifrac", weighted=T)
# Save the percent variance explained by the axes as a vector to use in plots.
eigen_percent <- ordinated$values$Relative_eig
# Save the percent variance explained as a txt file.
Eigen(eigen.input = eigen_percent, output.fn="results/eigen_percent.txt")
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data= meta, output.fn= "results/meta_users.txt")
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
scale_color_manual(values = distinct100colors) + # OR use viridis theme.
# scale_color_viridis_d() +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
theme1
p1
# Add ellipses at a desired confidence level.
p1 + stat_ellipse(level=0.95)
# Add lines to connect samples in order of the variable on the x axis.
p1 + geom_line(aes(color = UserName))
# Add lines to connect samples in the order in which they appear in the data.
p1 + geom_path(aes(color = UserName))
# Add ellipses at a desired confidence level.
p1 + stat_ellipse(level=0.95)
# make a polygon by UserName
p1 + geom_polygon(aes(fill = UserName)) + geom_point(aes(color=UserName), size=3) +
scale_fill_manual(values=distinct100colors)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight one sample with others being grey.
select_point_1 <- subset(meta_usersdf, UserName=="MCTs11")
p1 + geom_point(size=2, color="grey") +
geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=2)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight multiple samples with others being grey.
select_points <- subset(meta_usersdf, UserName=="MCTs11" | UserName=="MCTs12" )
p1 + geom_point(data=select_points, aes(x=Axis.1, y=Axis.2, color=as.factor(UserName))) +
scale_color_manual(values = c("MCTs11"="red", "MCTs12"="blue"))
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight one sample; other points will retain their original colors.
select_point_1 <- subset(meta_usersdf, UserName=="MCTs11")
# Changing the shape sizes might help find the dots. Note that points may be overlapping
p1 + geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=4)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight multiple samples; other points will retain their original colors.
select_point_1 <- subset(meta_usersdf, UserName=="MCTs11")
select_point_2 <- subset(meta_usersdf, UserName=="MCTs12")
p1 + geom_point(data=select_point_1, aes(x=Axis.1, y=Axis.2), color="black", size=4) +
geom_point(data=select_point_2, aes(x=Axis.1, y=Axis.2), color="green", size=4)
# Save the metadata and axis values as a txt file.
write.table(meta_usersdf, "results/ordinated_meta_users.txt", sep="\t", row.names = F)
# ---------------------------------------------------------------------------------------------------------------
# Perform Principal Coordinate Analysis (PCoA) with UNweighted unifrac distance of your food data.
# This may take a few minutes depending on your data size.
# e.g. takes ~ 1 min to process a 7.9-MB phyloseq object .
ordinated = phyloseq::ordinate(phyfoods, method="PCoA", distance="unifrac", weighted=FALSE)
# Save the percent variance explained by the axes as a vector to use in plots.
eigen_percent <- ordinated$values$Relative_eig
# Merge the first n axes to the metadata and save it as a txt file.
# The merged dataframe, 'meta_usersdf', will be used for plotting.
MergeAxesAndMetadata(ord.object=ordinated, number.of.axes=10, meta.data= meta, output.fn= "results/ordinated_unweighted_meta_users.txt")
# Plot Axis 1 and Axis 2 to show the separation of samples colored by UserName, gender, timing, etc. as in the metadata
p1 <- ggplot(meta_usersdf, aes(x=Axis.1, y=Axis.2, color=UserName)) +
geom_point(aes(color=UserName)) +
scale_color_manual(values = distinct100colors) + # OR use viridis theme.
# scale_color_viridis_d() +
xlab( paste("Axis.1 (", paste(round(eigen_percent[1]*100, 1)), "%)", sep="") ) +
ylab( paste("Axis.2 (", paste(round(eigen_percent[2]*100, 1)), "%)", sep="") ) +
theme1
p1
# Add ellipses at a desired confidence level.
p1 + stat_ellipse(level=0.95)
# Add lines to connect samples in order of the variable on the x axis.
p1 + geom_line(aes(color = UserName))
# Add lines to connect samples in the order in which they appear in the data.
p1 + geom_path(aes(color = UserName))
# make a polygon by UserName
p1 + geom_polygon(aes(fill = UserName)) + geom_point(aes(color=UserName), size=3) +
scale_fill_manual(values=distinct100colors)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Highlight multiple samples with others being grey.
select_points <- subset(meta_usersdf, UserName=="MCTs11" | UserName=="MCTs12" )
p1 + geom_point(data=select_points, aes(x=Axis.1, y=Axis.2, color=as.factor(UserName))) +
scale_color_manual(values = c("MCTs11"="red", "MCTs12"="blue"))
plot_ordination(phyloseq=phyfoods, ordination = ordinated, type="samples", color="UserName")
plot_ordination(phyfoods, ordination = ordinated, type="samples", color="UserName")
