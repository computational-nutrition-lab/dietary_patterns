length(days)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
daysvector
days <- order(unique(df$RecallNo), decreasing = FALSE)
days
order(days)
is(days)
days <- order(unique(df$RecallNo), decreasing = T)
days
days <- order(unique(df$RecallNo), decreasing = F)
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
daysvector
usersvector
daysvector
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
head(colnames(df))
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
head(colnames(df))
full_user_day
# Change the colnames slightly so that .x or .y won't be inserted after merging.
names(full_user_day)
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
colnames(full_user_day)
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
head(colnames(df))
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
head(colnames(df_w_NA))
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA$KCAL), ]
rows_w_NA
# vector of partial users
partial_users <- unique(rows_w_NA$UserName)
partial_users
rows_w_NA$UserName
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
partial_users
full_df <- subset(df, !UserName %in% partial_users) # pick up df records of users who are not partial.
head(full_df[,1])
# Plot points and lines separately.
ggplot() +
geom_point(df, mapping = aes(x=RecallNo, y=KCAL, group=UserName, color=UserName)) +
geom_line(full_df, mapping = aes(x=RecallNo, y=KCAL, group=UserName, color=UserName), linetype="dashed")
# Plot points and lines separately.
ggplot() +
geom_point(df, mapping = aes(x=RecallNo, y=KCAL, group=UserName, color=UserName)) +
geom_line(full_df, mapping = aes(x=RecallNo, y=KCAL, group=UserName, color=UserName), linetype="dashed") +
no_grid
df$RecallNo <- as.factor(df$RecallNo)
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
daysvector
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
head(colnames(df))
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
head(colnames(df_w_NA))
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA$KCAL), ]
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
full_df <- subset(df, !UserName %in% partial_users) # pick up df records of users who are not partial.
full_users <- unique(full_df$UserName) # Not needed for ggplot, but FYI...
head(full_df[, "UserName"])
# Plot points and lines separately.
ggplot() +
geom_point(df, mapping = aes(x=RecallNo, y=KCAL, group=UserName, color=UserName)) +
geom_line(full_df, mapping = aes(x=RecallNo, y=KCAL, group=UserName, color=UserName), linetype="dashed") +
no_grid
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, variable){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
df[, day]  <-  factor(df[, day])
print(str(df))
print(username)
print(variable)
}
df
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName", variable="KCAL")
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, variable){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, variable]), ]
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
print(partial_users)
# print(str(df))
# print(username)
# print(variable)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName", variable="KCAL")
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, variable){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, variable]), ]
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, UserName]) # Not needed for ggplot, but FYI...
print(full_df)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName", variable="KCAL")
colnames(full_df)
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, variable){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, variable]), ]
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
# full_users <- unique(full_df[, UserName]) # Not needed for ggplot, but FYI...
print(full_df)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName", variable="KCAL")
full_df[, UserName]
full_df[, "UserName"]
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, variable){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, variable]), ]
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, "UserName"]) # Not needed for ggplot, but FYI...
print(full_users)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName", variable="KCAL")
colnames(full_df)
df_w_NA
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, UserName]), ]  # UserName could eb RecallNo or KCAL...
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, "UserName"]) # Not needed for ggplot, but FYI...
}
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, outfn){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, UserName]), ]  # UserName could eb RecallNo or KCAL...
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, "UserName"]) # Not needed for ggplot, but FYI...
# Save the full_df with NA inserted for chart-making
write.table(x=full_df, file = outfn, sep="\t", row.names = F, quote=F)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName",
outfn = "VVKAJ_2021-11-09_7963_Tot_m_QCed_wNA.txt")
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, outfn){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
print(daysvector)
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, "UserName"]), ]  # UserName could eb RecallNo or KCAL...
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, "UserName"]) # Not needed for ggplot, but FYI...
# Save the full_df with NA inserted for chart-making
write.table(x=full_df, file = outfn, sep="\t", row.names = F, quote=F)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName",
outfn = "VVKAJ_2021-11-09_7963_Tot_m_QCed_wNA.txt")
View(rows_w_NA)
View(tot_m_QCed_full_users)
View(df_w_NA)
ggplot(df, aes(x=as.factor(RecallNo), y=TFAT, group=UserName)) +
geom_line(linetype="dashed", aes(color=UserName)) +
geom_point(aes(color=UserName)) +
# xlab("Day") + # Re-annotate the X-axis label.
no_grid
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, all.fn, full.days.only.fn){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, "UserName"]), ]  # UserName could eb RecallNo or KCAL...
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, "UserName"]) # Not needed for ggplot, but FYI...
# all data with NA inserted
write.table( x=rows_w_NA, file = all.fn, sep="\t", row.names = F, quote=F)
# Save users' rows with full data only
write.table( x=full_df, file = full.days.only.fn, sep="\t", row.names = F, quote=F)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName",
all.fn="VVKAJ_2021-11-09_7963_Tot_m_QCed_wNA.txt",
full.days.only.fn="VVKAJ_2021-11-09_7963_Tot_m_QCed_fullonly.txt")
# ========================================================================
#  make this into function
PrepLinePlot <- function(inputdf, day, username, all.fn, full.days.only.fn){
df <- inputdf
# Define users and days in your df
users <- unique(df[, username])
days  <- order(unique(df[, day]), decreasing = F)
# Make day as a factor.
df[, day]  <-  factor(df[, day])
# Create a character vector to be "users"
usersvector = rep(users, length(days))
# Create a character vector to be "days"
daysvector <- character(0)
k = length(users)
# Repeat each day as many as there are users.
for(i in 1:length(days)){
if(i==1){daysvector = rep(days[i], k)}else{daysvector = c(daysvector, rep(days[i], k) ) }
}
full_user_day = data.frame(UserName = usersvector, RecallNo = daysvector)
# Add a column of user_day
full_user_day$User_Day = paste(full_user_day$UserName, full_user_day$RecallNo, sep="_")
# Change the colnames slightly so that .x or .y won't be inserted after merging.
# Leave "User_Day" as is, because this is needed for merging.
colnames(full_user_day) <- c("UserName_a", "RecallNo_a", "User_Day")
# Also add a column of user_day to df.
# df may already have User_Day, but it won't hurt to make it again.
# df$User_Day = paste(df$UserName, df$RecallNo, sep="_")
df$User_Day = paste(df[, username], df[, day], sep="_")
# Merge, so that the rows absent in full_user_day will be NA.
df_w_NA <- merge(x=full_user_day, y=df, by="User_Day", all.x=TRUE)
# pick up UserName that has NA values
rows_w_NA <- df_w_NA[is.na(df_w_NA[, "UserName"]), ]  # UserName could eb RecallNo or KCAL...
# vector of partial users
partial_users <- unique(rows_w_NA$UserName_a) # UserName_a has actual UserNames.
# pick up df records of users who are not partial.
full_df <<- subset(df, !UserName %in% partial_users)
full_users <- unique(full_df[, "UserName"]) # Not needed for ggplot, but FYI...
# all data with NA inserted
write.table( x=df_w_NA, file = all.fn, sep="\t", row.names = F, quote=F)
# Save users' rows with full data only
write.table( x=full_df, file = full.days.only.fn, sep="\t", row.names = F, quote=F)
}
PrepLinePlot(inputdf=df, day="RecallNo", username="UserName",
all.fn=           "VVKAJ_2021-11-09_7963_Tot_m_QCed_wNA.txt",
full.days.only.fn="VVKAJ_2021-11-09_7963_Tot_m_QCed_fullonly.txt")
