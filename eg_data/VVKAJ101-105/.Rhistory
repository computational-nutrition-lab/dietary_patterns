max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=10,
max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=20,
max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=20,
max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=T)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=15,
max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=30,
max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=5,
max.words = 400, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud(words=bbb$mycol, freq=bbb$Freq, min.freq=5,
max.words = 100, random.order=F, rot.per=0,
colors=brewer.pal(8, "Dark2"), fixed.asp=F)
wordcloud2(data=bbb, size=1.6, color='random-dark')
head(sortedbbb,15)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
# NUMERIC ----
bbb = as.data.frame(table(mycol))
bbb
colnames(bbb)
sortedbbb = bbb[ order(bbb$Freq, decreasing = T), ]
sortedbbb
write.table(as.data.frame(sortedbbb), "clipboard", sep="\t", row.names=F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
# NUMERIC ----
bbb = as.data.frame(table(mycol))
bbb
sortedbbb = bbb[ order(bbb$Freq, decreasing = T), ]
sortedbbb
head(sortedbbb)
write.table(as.data.frame(sortedbbb), "clipboard", sep="\t", row.names=F)
female = read.table(file="clipboard", sep="\t", header=T)
head(female, 20)
nrow(female)
male = read.table(file="clipboard", sep="\t", header=T)
head(male, 20)
nrow(male)
names(female)
names(female)[2] <- "female_freq"
nrow(female)
head(female, 20)
names(male)[2] <- "male_freq"
head(male, 20)
fandm <- merge(x=female, y=male, all = T, by="mycol")
head(fandm)
ttwoway <- fandm
Total = colSums(t(ttwoway)) # Column totals
fandm_zeros[ is.na(fandm_zeros) ] <- 0
fandm_zeros <- fandm # make a copy
fandm_zeros[ is.na(fandm_zeros) ] <- 0
head(fandm_zeros)
ttwoway <- fandm_zeros
Total = colSums(t(ttwoway)) # Column totals
write.table(fandm_zeros, "clipboard", sep='\t')
write.table(fandm_zeros, "clipboard", sep='\t', row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
# NUMERIC ----
bbb = as.data.frame(table(mycol))
bbb
sortedbbb = bbb[ order(bbb$Freq, decreasing = T), ]
sortedbbb
table(sortedbbb$Freq)
sum(sortedbbb$Freq)
write.table(as.data.frame(sortedbbb), "clipboard", sep="\t", row.names=F)
colnames(bbb)
bbb
write.table(bbb, "clipboard", sep="\t", row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
# NUMERIC ----
bbb = as.data.frame(table(mycol))
bbb
write.table(bbb, "clipboard", sep="\t", row.names = F)
nrow(mycol)
head(mycol, 20)
unique(mycol)
uniquenames = unique(mycol)
write.table(uniquenames, "clipboard", sep="\t", row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
uniquenames = unique(mycol)
sort(uniquenames)
order(uniquenames)
uniquenames
write.table(uniquenames, "clipboard", sep="\t", row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
# NUMERIC ----
bbb = as.data.frame(table(mycol))
bbb
write.table(bbb, "clipboard", sep="\t", row.names = F)
# Useful! Get counts of data from Excel =========================================================
# Get data (One column) from Clipboard ================================================
mycol = read.table(file="clipboard", sep=",") # sep="," for 1 column, sep="\t" for multiple columns
head(mycol, 20)
nrow(mycol)
# Freq table with 2 variables.===========================================================
mydata = read.table(file="clipboard", sep="\t", header =T) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
mydata = read.table(file="clipboard", sep="\t", header =f) # sep="," for 1 column, sep="\t" for multiple columns
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
V1table = as.data.frame(table(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
V1table = as.data.frame(table(mydata$V1))
V1table
sortedV1table = V1table[ order(V1table$Freq, decreasing = T), ]  # sort by col totals
sortedV1table
write.table(sortedV1table, "clipboard", sep="\t", row.names = F)
length(unique(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
V1table = as.data.frame(table(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
V1table = as.data.frame(table(mydata$V1))
V1table
length(unique(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
sortedV1table = V1table[ order(V1table$Freq, decreasing = T), ]  # sort by col totals
write.table(sortedV1table, "clipboard", sep="\t", row.names = F)
# generate a two-way parents' frequency table
female = read.table(file="clipboard", sep="\t", header=T)
head(female, 20)
nrow(female)
# generate a two-way parents' frequency table
female = read.table(file="clipboard", sep="\t", header=F)
head(female, 20)
nrow(female)
names(female)
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
V1table = as.data.frame(table(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
sortedV1table = V1table[ order(V1table$Freq, decreasing = T), ]  # sort by col totals
write.table(sortedV1table, "clipboard", sep="\t", row.names = F)
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
V1table = as.data.frame(table(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
sortedV1table = V1table[ order(V1table$Freq, decreasing = T), ]  # sort by col totals
write.table(sortedV1table, "clipboard", sep="\t", row.names = F)
# generate a two-way parents' frequency table
female = read.table(file="clipboard", sep="\t", header=F)
head(female, 20)
nrow(female)
# generate a two-way parents' frequency table
female = read.table(file="clipboard", sep="\t", header=F)
head(female, 20)
nrow(female)
names(female)[2] <- "female_freq"
male = read.table(file="clipboard", sep="\t", header=T)
head(male, 20)
nrow(male)
nrow(male)
names(male)[2] <- "male_freq"
head(female, 20)
# generate a two-way parents' frequency table
female = read.table(file="clipboard", sep="\t", header=T)
head(female, 20)
nrow(female)
names(female)[2] <- "female_freq"
head(female, 20)
head(male, 20)
fandm <- merge(x=female, y=male, all = T, by="Val1")
fandm <- merge(x=female, y=male, all = T, by="Var1")
head(fandm)
# replace NAs with zero.
fandm_zeros[ is.na(fandm_zeros) ] <- 0
fandm_zeros <- fandm # make a copy
# replace NAs with zero.
fandm_zeros[ is.na(fandm_zeros) ] <- 0
head(fandm_zeros)
write.table(fandm_zeros, "clipboard", sep='\t', row.names = F)
ttwoway <- fandm_zeros
Total = colSums(t(ttwoway)) # Column totals
mydata = read.table(file="clipboard", sep="\t", header =F) # sep="," for 1 column, sep="\t" for multiple columns
# write.table(mycol, "clipboard", sep="\t")
# mydata
head(mydata)
tail(mydata)
nrow(mydata)
V1table = as.data.frame(table(mydata$V1))
write.table(V1table, "clipboard", sep="\t", row.names = F)
sortedV1table = V1table[ order(V1table$Freq, decreasing = T), ]  # sort by col totals
write.table(V1table, "clipboard", sep="\t", row.names = F)
# Set where the NHANES data and food code table are.
# it is not in the eg_data folder because it's too large to save in GitHub folder.
# setwd("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16")
setwd("~/GitHub/dietary_patterns")
source("lib/load_clean_ASA24.R")
View(SpecifyDataDirectory)
View(SpecifyDataDirectory)
View(SpecifyDataDirectory)
# Load the items
items <- read.table("eg_data/dietstudy/Items_to_use.txt", quote = "", sep = "\t", header = T)
# Load the totals
totals <- read.table("eg_data/dietstudy/Totals_to_use.txt", sep = "\t", header = T)
# ========================================================================================
# <Optional> Use individuals_to_remove.txt to filter out users marked as Remove = yes.
# ========================================================================================
# Load your metadata that has information about which UserName(s) to remove.
ind_to_rm <- read.delim("eg_data/VVKAJ101-105/individuals_to_remove.txt", header=T)
ind_to_rm
# Show which has "yes" in the "Remove" column, and remove them.
subset(ind_to_rm, Remove == "yes")
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
RemoveRows(data=totals, metadata.file=ind_to_rm, output.name="eg_data/VVKAJ101-105/selectedtotals.txt")
source("lib/load_clean_ASA24.R")
format.file <- function(filename, columns, outdir)
{
data0 <- read.table(filename,
sep = "\t",
header = TRUE)
for(i in 1:length(columns))
{
col <- columns[i]
# Formatting column text string to work with newick tree
# Remove any leading or trailing spaces in the food descriptions
data0[,col]<- gsub("^\\s+|\\s+$", "", data0[,col])
# Remove non-text characters
data0[,col]<- gsub('[():;,/-]+', "", data0[,col])
# Remove pesky apostropies
data0[,col]<- gsub("'", '', data0[,col])
# Remove pesky percent symbols
data0[,col]<-gsub("%", '', data0[,col])
# Replace spaces with underscores
data0[,col]<- gsub(' ','_', data0[,col])
}
# If want to overwrite the data, write out to file
write.table(data0, file=outdir, sep = "\t", quote = FALSE, row.names = FALSE)
# # If do not want to overwrite data...
# data1 <- data0[,c(foodcodecolname, columns)]
#
# # write out to file
# write.table(data1, file=outdir, sep = "\t", quote = FALSE, row.names = FALSE)
}
# Load your raw items data.
items_raw <- read.csv("VVKAJ_2021-11-09_7963_Items.csv", sep = ",", header=T)
# Load your raw items data.
items_raw <- read.csv("eg_data/VVKAJ_2021-11-09_7963_Items.csv", sep = ",", header=T)
# Load your raw items data.
items_raw <- read.csv("eg_data/VVKAJ101-105/VVKAJ_2021-11-09_7963_Items.csv", sep = ",", header=T)
head(items_raw)
# ========================================================================================
# Load data
# ========================================================================================
# Specify the directory where the data is.
SpecifyDataDirectory(directory.name = "eg_data/VVKAJ101-105/")
# Name your main directory for future use.
main.wd <- file.path(getwd())
# Import source code to run the analyses to follow.
source("lib/specify_dir_and_check_col.R")
# Specify the directory where the data is.
SpecifyDataDirectory(directory.name = "eg_data/VVKAJ101-105/")
# Replace special characters with space or underscore. Takes only .txt files as input.
format.file(filename = "VVKAJ_2021-11-09_7963_Items.txt",
columns =  "Food_Description",
outdir =   "VVKAJ_2021-11-09_7963_Items_f.txt")  # _f stands for "formatted".
# Save it as a .txt file for further processing.
write.table(items_raw, "VVKAJ_2021-11-09_7963_Items.txt", sep="\t", row.names=F)
# Replace special characters with space or underscore. Takes only .txt files as input.
format.file(filename = "VVKAJ_2021-11-09_7963_Items.txt",
columns =  "Food_Description",
outdir =   "VVKAJ_2021-11-09_7963_Items_f.txt")  # _f stands for "formatted".
# Load the formatted Items file.
items_f <- read.table("VVKAJ_2021-11-09_7963_Items_f.txt", sep="\t", header=T)
# Check
head(items_f)
grep(pattern=",", x=items_raw)
grep(pattern=",", x=items_raw$Food_Description)
head(items_raw, 1)
View(format.file)
# Ensure that
head(items_f)
# ========================================================================================
# <Optional> Use individuals_to_remove.txt to filter out users marked as Remove = yes.
# ========================================================================================
# Load your metadata that has information about which UserName(s) to remove.
ind_to_rm <- read.delim("individuals_to_remove.txt", header=T)
# ========================================================================================
# <Optional> Use individuals_to_remove.txt to filter out users marked as Remove = yes.
# ========================================================================================
# Load your metadata that has information about which UserName(s) to remove.
ind_to_rm <- read.delim("individuals_to_remove.txt", header=T)
head(ind_to_rm)
ind_to_rm
# Show which has "yes" in the "Remove" column, and remove them.
subset(ind_to_rm, Remove == "yes")
View(RemoveRows)
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
# This assumes the user names are in UserName column.
RemoveRows(data=items,  metadata.file=ind_to_rm, output.name="selecteditems.txt")
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items <-  read.delim("selecteditems.txt", header=T, sep="\t")
# Load metadata 2
# ind_metadata <- read.table("eg_data/dietstudy/dietstudy_metadata.txt", sep="\t", header=T)
ind_metadata <- read.table("ind_metadata.txt", sep="\t", header=T)
head(ind_metadata)
# Add this metadata of each participant in totals or items.
# 'NA' will be inserted to UserNames which are not in ind_metadata.
# totals <- merge(x=totals, y=ind_metadata, by="UserName", all.x=T)
items <- merge(x=items, y=ind_metadata, by="UserName", all.x=T)
head(items)
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items <-  read.delim("selecteditems.txt", header=T, sep="\t")
items
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items <-  read.table("selecteditems.txt", header=T, sep="\t")
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
# This assumes the user names are in UserName column, and will print which user(s) will be removed.
RemoveRows(data=items_f,  metadata.file=ind_to_rm, output.name="VVKAJ_2021-11-09_7963_Items_f_s.txt")
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items <-  read.table("VVKAJ_2021-11-09_7963_Items_f_s.txt", header=T, sep="\t")
unique(items$UserName)
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items_f_s <-  read.table("VVKAJ_2021-11-09_7963_Items_f_s.txt", header=T, sep="\t")
# Add this metadata of each participant in totals or items.
# 'NA' will be inserted to UserNames which are not in ind_metadata.
# totals <- merge(x=totals, y=ind_metadata, by="UserName", all.x=T)
items_f_s_m <- merge(x=items_f_s, y=ind_metadata, by="UserName", all.x=T)
head(items_f_s_m)
colnames(items_f_s)
View(RemoveRows)
# ---------------------------------------------------------------------------------------------------------------
# Function to QC rows of 'totals' by Metadata
# Show which has "yes" in the "Remove" column, and remove them.
RemoveRows <- function(data, metadata.file, output.name){
toberemoved <- subset(metadata.file, Remove=="yes")
cat(nrow(toberemoved), "row(s) below are to be removed:", "\n")
print(toberemoved)
# Merge the data and metadata.
merged <- merge(x=data, y=metadata.file, by="UserName", all.x=T)
# Remove the rows that have "yes" in the "Remove" column.
selected_data <<- subset(merged, Remove!="yes")
# Now can omit the "Remove" column.
selected_data_2 <<- selected_data[, -Remove]
# Save externally.
write.table(selected_data_2, output.name, sep="\t", row.names=F, quote=F)
}
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
# This assumes the user names are in UserName column, and will print which user(s) will be removed.
RemoveRows(data=items_f,  metadata.file=ind_to_rm, output.name="VVKAJ_2021-11-09_7963_Items_f_s.txt")
# ---------------------------------------------------------------------------------------------------------------
# Function to QC rows of 'totals' by Metadata
# Show which has "yes" in the "Remove" column, and remove them.
RemoveRows <- function(data, metadata.file, output.name){
toberemoved <- subset(metadata.file, Remove=="yes")
cat(nrow(toberemoved), "row(s) below are to be removed:", "\n")
print(toberemoved)
# Merge the data and metadata.
merged <- merge(x=data, y=metadata.file, by="UserName", all.x=T)
# Remove the rows that have "yes" in the "Remove" column.
selected_data <<- subset(merged, Remove!="yes")
# Now can omit the "Remove" column.
selected_data_2 <<- selected_data[, -"Remove"]
# Save externally.
write.table(selected_data_2, output.name, sep="\t", row.names=F, quote=F)
}
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
# This assumes the user names are in UserName column, and will print which user(s) will be removed.
RemoveRows(data=items_f,  metadata.file=ind_to_rm, output.name="VVKAJ_2021-11-09_7963_Items_f_s.txt")
# ---------------------------------------------------------------------------------------------------------------
# Function to QC rows of 'totals' by Metadata
# Show which has "yes" in the "Remove" column, and remove them.
RemoveRows <- function(data, metadata.file, output.name){
toberemoved <- subset(metadata.file, Remove=="yes")
cat(nrow(toberemoved), "row(s) below are to be removed:", "\n")
print(toberemoved)
# Merge the data and metadata.
merged <- merge(x=data, y=metadata.file, by="UserName", all.x=T)
# Remove the rows that have "yes" in the "Remove" column.
selected_data <<- subset(merged, Remove!="yes")
# Now can omit the "Remove" column.
selected_data_2 <<- selected_data[, -which(names(selected_data0) %in% "Remove")]
# Save externally.
write.table(selected_data_2, output.name, sep="\t", row.names=F, quote=F)
}
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
# This assumes the user names are in UserName column, and will print which user(s) will be removed.
RemoveRows(data=items_f,  metadata.file=ind_to_rm, output.name="VVKAJ_2021-11-09_7963_Items_f_s.txt")
# ---------------------------------------------------------------------------------------------------------------
# Function to QC rows of 'totals' by Metadata
# Show which has "yes" in the "Remove" column, and remove them.
RemoveRows <- function(data, metadata.file, output.name){
toberemoved <- subset(metadata.file, Remove=="yes")
cat(nrow(toberemoved), "row(s) below are to be removed:", "\n")
print(toberemoved)
# Merge the data and metadata.
merged <- merge(x=data, y=metadata.file, by="UserName", all.x=T)
# Remove the rows that have "yes" in the "Remove" column.
selected_data <<- subset(merged, Remove!="yes")
# Now can omit the "Remove" column.
selected_data_2 <<- selected_data[, -which(names(selected_data) %in% "Remove")]
# Save externally.
write.table(selected_data_2, output.name, sep="\t", row.names=F, quote=F)
}
# Data after QC is named as selected_data, and is saved as a text file with the specified name.
# This assumes the user names are in UserName column, and will print which user(s) will be removed.
RemoveRows(data=items_f,  metadata.file=ind_to_rm, output.name="VVKAJ_2021-11-09_7963_Items_f_s.txt")
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items_f_s <-  read.table("VVKAJ_2021-11-09_7963_Items_f_s.txt", header=T, sep="\t")
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items_f_s <-  read.table("VVKAJ_2021-11-09_7963_Items_f_s.txt", header=T, sep="\t")
colnames(items_f_s)
View(selected_data)
colnames(selected_data)
colnames(selected_data2)
colnames(selected_data_2)
# Load the selected data for further processing.
# totals <- read.table("selectedtotals.txt", header=T, sep="\t")
items_f_s <- read.table("VVKAJ_2021-11-09_7963_Items_f_s.txt", header=T, sep="\t")
# Load metadata 2
# ind_metadata <- read.table("eg_data/dietstudy/dietstudy_metadata.txt", sep="\t", header=T)
ind_metadata <- read.table("ind_metadata.txt", sep="\t", header=T)
# Look at what the metadata has.
head(ind_metadata)
# Add this metadata of each participant in totals or items.
# 'NA' will be inserted to UserNames which are not in ind_metadata.
# totals <- merge(x=totals, y=ind_metadata, by="UserName", all.x=T)
items_f_s_m <- merge(x=items_f_s, y=ind_metadata, by="UserName", all.x=T)
head(items_f_s_m)
# ---------------------------------------------------------------------------------------------------------------
# Function to QC rows of 'totals' by Metadata
# Show which has "yes" in the "Remove" column, and remove them.
RemoveRows <- function(data, metadata.file, output.name){
toberemoved <- subset(metadata.file, Remove=="yes")
cat(nrow(toberemoved), "row(s) below are to be removed:", "\n")
print(toberemoved)
# Merge the data and metadata.
merged <- merge(x=data, y=metadata.file, by="UserName", all.x=T)
# Remove the rows that have "yes" in the "Remove" column.
selected_data <- subset(merged, Remove!="yes")
# Now can omit the "Remove" column.
selected_data_2 <- selected_data[, -which(names(selected_data) %in% "Remove")]
# Save externally.
write.table(selected_data_2, output.name, sep="\t", row.names=F, quote=F)
}
# Use VVKAJ data. --------------------------------------------------------
GenerateTotals(items.data=items, User.Name='UserName', Recall.No='RecallNo')
# Use VVKAJ data. --------------------------------------------------------
GenerateTotals(items.data=items_f_s_m, User.Name='UserName', Recall.No='RecallNo')
# The number of rows should be {No. of users x No. days}.
dim(New_Totals)
head(New_Totals, 2)
