# Loc=       as.factor(df$Loc),
# Year=      as.factor(df$Year),
Ave_Tru_L= as.numeric(df$Ave_Tru_L),  # Change this trait name
LocYear=   as.factor(df$LocYear)
)
str(Longtable)
Longtable %>% filter(Year=="2018") %>% filter(Loc=="NE")
#
Longtable <-transform(df,
Geno=      as.factor(df$Geno),
Loc=       as.factor(df$Loc),
Year=      as.factor(df$Year),
Ave_Tru_L= as.numeric(df$Ave_Tru_L),  # Change this trait name
LocYear=   as.factor(df$LocYear)
)
# Other ways to check if the violin plot is correct
Longtable %>% filter(Year=="2018") %>% filter(Loc=="NE") %>%
ggplot(aes(Ave_Tru_L)) +
geom_histogram() + coord_flip()
Longtable %>% filter(Year=="2018") %>% filter(Loc=="NE") %>% summarise(medi = mean(Ave_Tru_L))
str(Longtable)
Longtable %>% filter(Year=="2018") %>% filter(Loc=="NE") %>% summarise(medi = median(Ave_Tru_L, na.rm = T))
Longtable %>% filter(Year=="2019") %>% filter(Loc=="NE") %>% summarise(medi = median(Ave_Tru_L, na.rm = T))
Longtable %>% filter(Year=="2019") %>% filter(Loc=="MI") %>% summarise(medi = median(Ave_Tru_L, na.rm = T))
Longtable %>% filter(Year=="2018") %>% filter(Loc=="MI") %>% summarise(medi = median(Ave_Tru_L, na.rm = T))
# Generate a histogram for a particular environment.
Longtable %>% filter(Year=="2018") %>% filter(Loc=="NE") %>%
ggplot(aes(Ave_Tru_L)) +
geom_density() + coord_flip()
# Generate a histogram for a particular environment.
Longtable %>% filter(Year=="2019") %>% filter(Loc=="NE") %>%
ggplot(aes(Ave_Tru_L)) +
geom_density() + coord_flip()
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar.
geom = "crossbar",
width = 1.05,
position = position_dodge(width = 1.05)) +
# theme(panel.grid = element_blank()) +
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like.
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar
geom = "crossbar",
width = 1.05,
position = position_dodge(width = 1.05)) +
theme(panel.grid = element_blank()) +    # Remove the grid within the panel
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar
geom = "crossbar",
width = 1.05,
# position = position_dodge(width = 1.05)) +
position = position_dodge(width = 2)) +
theme(panel.grid = element_blank()) +    # Remove the grid within the panel
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar
geom = "crossbar",
width = 1.05) +
# position = position_dodge(width = 1.05)) +
# position = position_dodge(width = 2)) +
theme(panel.grid = element_blank()) +    # Remove the grid within the panel
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar
geom = "crossbar",
width = 1.05,
position = position_dodge(width = 1)) +
theme(panel.grid = element_blank()) +    # Remove the grid within the panel
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar
geom = "crossbar",
width = 1.05,
position = position_dodge(width = 1.05)) +
theme(panel.grid = element_blank()) +    # Remove the grid within the panel
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
# --------------------------------------------------------------------------------------------------------------
# Violin plot
myplot <- ggplot(Longtable, aes(x=Loc, y=Ave_Tru_L, fill=Year)) +      # CHANGE ARGUMENTS HERE
geom_split_violin(trim=TRUE, show.legend = F) +
theme_bw(base_size = 18) +
scale_fill_manual(values=c('#FF6649', '#6395ED'),  # Fill colors
guide = guide_legend(override.aes =
list(color=c('#FF6649', '#6395ED'), fill=c('#FF6649', '#6395ED')))) +
stat_summary(fun = median,      # Add a median bar
geom = "crossbar",
width = 1.05,
position = position_dodge(width = 1.05)) +
theme(panel.grid = element_blank()) +    # Remove the grid within the panel
theme(legend.title = element_blank()) +
theme(legend.position = c(0.1, 0.1)) +
theme(legend.background = element_rect(fill = "transparent", colour = NA)) +
ylab("Calibrated L*") +                  # Change Y axis title if you'd like
theme(axis.title.x = element_blank()) +
theme(axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0))) +
theme(axis.text.x = element_text(color='black'),
axis.text.y = element_text(color='black'))
myplot
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # txt
# Take a look at the first 6 rows of your dataframe (df).
head(df)
# Ensure your df has the correct number of rows and columns.
dim(df)
# --------------------------------------------------------------------------------------------------------------
# Load your dataset.
df <- read.csv(  "Longtable_Tru_L.csv", header=T) # csv
# Take a look at the first 6 rows of your dataframe (df).
head(df)
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
# Take a look at the first 6 rows of your dataframe (df).
head(df)
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
# Take a look at the first 6 rows of your dataframe (df).
head(df)
# Ensure your df has the correct number of rows and columns.
dim(df)
# --------------------------------------------------------------------------------------------------------------
# Load your dataset.
df <- read.csv(  "Longtable_Tru_L.csv", header=T) # csv OR
# Take a look at the first 6 rows of your dataframe (df).
head(df)
# Ensure your df has the correct number of rows and columns.
dim(df)
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
df %>% is.na(Ave_Tru_L)
is.na(df$Ave_Tru_L)
# --------------------------------------------------------------------------------------------------------------
# Load your dataset.
df <- read.csv(  "Longtable_Tru_L.csv", header=T) # csv OR
is.na(df$Ave_Tru_L)
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
is.na(df$Ave_Tru_L)
# Take a look at the first 6 rows of your dataframe (df).
head(df)
# Ensure your df has the correct number of rows and columns.
dim(df)
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
# Ensure your df has the correct number of rows and columns.
dim(df)
# Ensure your df has the correct number of rows and columns.
dim(df)
#
Longtable <-transform(df,
Geno=      as.factor(df$Geno),
Loc=       as.factor(df$Loc),
Year=      as.factor(df$Year),
Ave_Tru_L= as.numeric(df$Ave_Tru_L),  # Change this trait name
LocYear=   as.factor(df$LocYear)
)
colSums(is.na(df$Ave_Tru_L))
colSums(is.na(df))
# --------------------------------------------------------------------------------------------------------------
# Load your dataset.
df <- read.csv(  "Longtable_Tru_L.csv", header=T) # csv OR
colSums(is.na(df))
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
colSums(is.na(df))
df <- read.table("Longtable_Tru_L.txt", header=T, sep="\t" ) # tab-delimited txt
# Take a look at the first 6 rows of your dataframe (df).
head(df)
# Ensure your df has the correct number of rows and columns.
dim(df)
# Convert some variables to factors and some to numeric.
Longtable <-transform(df,
Geno=      as.factor(df$Geno),
Loc=       as.factor(df$Loc),
Year=      as.factor(df$Year),
Ave_Tru_L= as.numeric(df$Ave_Tru_L),  # CHANGE TRAIT NAME HERE
LocYear=   as.factor(df$LocYear)
)
# See how many missing data are there in each column.
colSum(is.na(df))
# See how many missing data are there in each column.
colSums(is.na(df))
# Generate a smoothed line histogram for a particular environment.
Longtable %>% filter(Year=="2019") %>% filter(Loc=="NE") %>%
ggplot(aes(Ave_Tru_L)) +
geom_density() + coord_flip()
# ---------------------------------------------------------------------------------------------------------------
# Load the data of those to be used in the diabetes status analysis.
glu <- read.delim( file="QCtotalANDglu_body_meta.txt", sep= "\t", header= T )
# Set where the NHANES data and food code table are.
# It is not in the eg_data folder because it's too large to save in GitHub folder.
# setwd("E:/MSU OneDrive 20210829/UMinn/20_NHANES/2015-16")
setwd("~/GitHub/dietary_patterns")
# Load necessary functions.
source("lib/load_clean_NHANES.R")
source("lib/prep_data_for_clustering.R")
source("lib/ggplot2themes.R")
# ---------------------------------------------------------------------------------------------------------------
# Load the data of those to be used in the diabetes status analysis.
glu <- read.delim( file="QCtotalANDglu_body_meta.txt", sep= "\t", header= T )
vis_miss( glu[, c("SEQN", "DRQSDIET")] )
vis_miss( glu[, c("SEQN", "LBXGLU")] )
library(naniar)
library(naniar)
vis_miss( glu[, c("SEQN", "LBXGLU")] )
table(glu_2$DRQSDT2) # Should be zero.
vis_miss( glu[, c("SEQN", "LBXGLU")] )
# make GLU_index as a factor for plotting.
glu$GLU_index <- factor(glu$GLU_index, levels = c('Norm', 'Pred', 'Diab'))
# Exclude those who are following special diets.
# Extract only those following any specific diet.
table(QCtotalANDglu_body_meta$DRQSDIET)
table(glu$DRQSDIET)
# 1 is following a special diet.
library(dplyr)
glu_2 <- glu %>% filter(DRQSDIET == 2)
# safety check
table(glu_2$DRQSDT1) # Should be zero.
table(glu_2$DRQSDT2) # Should be zero.
vis_miss( glu_2[, c("SEQN", "LBXGLU")] )
# The sample size are OK..
table(glu_2$GLU_index)
# Look for column names that end with 'BMI'.
# Not super useful because all the variables start with "BMI", because the alphabet for 15-16 is "I",
# so the prefix "BMX" is "BMI" for these years....
grep("*BMI", colnames(glu_2) )
colnames(glu_2)[114]
summary(glu_2$BMXBMI)
vis_miss(glu_2[, c("SEQN", 'BMXBMI')])
# Make sure the labels in the legend are correct.
BMIfreq <- ggplot(data=glu_2, aes(x=BMXBMI, group=GLU_index, fill=GLU_index)) +
geom_density(adjust=1.5, alpha=.4) + space_axes + no_grid +
scale_fill_manual(values= c("steelblue3", "yellow", "hotpink") ,
labels= c("Normal", "Prediabetes", "Diabetes")) +
labs(x="BMI", y="Density")
BMIfreq
# Save the chart as .png. n=1554 - 14 missing= 1540.
ggsave("eg_data/NHANES/Laboratory_data/BMI_by_GLU_index_n1540.png", BMIfreq,  device="png")
# ---------------------------------------------------------------------------------------------------------------
# Look at the KCAL frequency of each group.
# Make sure the labels in the legend are correct.
colnames(glu_2)
KCALfreq <- ggplot(data=glu_2, aes(x=KCAL, group=GLU_index, color=GLU_index)) +
geom_density(adjust=1.5, alpha=.4, size=1.2, linetype="longdash") + space_axes + no_grid +
scale_color_manual(values= c("steelblue3", "gold3", "hotpink") ,
labels= c("Normal", "Prediabetes", "Diabetes")) +
labs(x="KCAL", y="Density")
KCALfreq
BMIfreq
# ---------------------------------------------------------------------------------------------------------------
# Look at the KCAL frequency of each group.
# Make sure the labels in the legend are correct.
colnames(glu_2)
KCALfreq <- ggplot(data=glu_2, aes(x=KCAL, group=GLU_index, color=GLU_index)) +
geom_density(adjust=1.5, alpha=.4, size=1.2, linetype="longdash") + space_axes + no_grid +
scale_color_manual(values= c("steelblue3", "gold3", "hotpink") ,
labels= c("Normal", "Prediabetes", "Diabetes")) +
labs(x="KCAL", y="Density")
KCALfreq
KCALfreq <- ggplot(data=glu_2, aes(x=KCAL, group=GLU_index, color=GLU_index)) +
geom_density(adjust=1.5, alpha=.4, size=1.2, linetype="longdash") + space_axes + no_grid +
# scale_color_manual(values= c("steelblue3", "gold3", "hotpink") ,
#                   labels= c("Normal", "Prediabetes", "Diabetes")) +
labs(x="KCAL", y="Density")
KCALfreq
KCALfreq <- ggplot(data=glu_2, aes(x=KCAL, group=GLU_index, color=GLU_index)) +
geom_density(adjust=1.5, alpha=.4, size=1.2, linetype="longdash") + space_axes + no_grid +
scale_color_manual(values= c("steelblue3", "gold3", "hotpink") ,
labels= c("Normal", "Prediabetes", "Diabetes")) +
labs(x="KCAL", y="Density")
KCALfreq
# ---------------------------------------------------------------------------------------------------------------
# Use the demographics results...
# ---------------------------------------------------------------------------------------------------------------
# Load the demographics data.
demo <- read.xport("eg_data/NHANES/DEMO_I.XPT")
tail(demo, 50)
dim(demo)
dim(glu)
grep("RIDAGEYR", colnames(glu_2))
grep("RIAGENDR", colnames(glu_2))
# Add the demographics info to glu_2.
glu_3 <- merge(x=glu_2, y=demo, all.x=T, by="SEQN") # 1554 rows.
colnames(glu_3)
# Gender - no missing data. 1: male, 2: female.
table(glu_3$RIAGENDR)
# Select males in their 50s
glu_3_males <- glu_3 %>% filter(RIAGENDR == 1)
glu_3_males50s <- glu_3_males %>% filter(RIDAGEYR >= 50 & RIDAGEYR <= 59 )
table(glu_3_males50s$RIDAGEYR)
table(glu_3_males50s$GLU_index)
colnames(glu_3_males50s)
# Look at the KCAL frequency of each group.
# Make sure the labels in the legend are correct.
KCALfreq_males50s <- ggplot(data=glu_3_males50s, aes(x=KCAL, group=GLU_index, color=GLU_index)) +
geom_density(adjust=1.5, alpha=.4, size=1.2, linetype="longdash") + space_axes + no_grid +
scale_color_manual(values= c("steelblue3", "gold3", "hotpink") ,
labels= c("Normal", "Prediabetes", "Diabetes")) +
labs(x="KCAL", y="Density")
KCALfreq_males50s
# Create a boxplot of KCAL of each GLU_index group.
KCAL_dots_males50s <- ggplot(glu_3_males50s, aes(x=GLU_index, y=KCAL)) +
geom_boxplot(outlier.shape = NA) + no_grid + space_axes +
geom_jitter(width=0.3)
KCAL_dots_males50s
# Perform PCA and plot the individuals. color code by GLU_index.
head(glu_3_males50s)
# Save the glu_3 as a txt file.
write.table(glu_3, "eg_data/NHANES/Laboratory_data/QCtotalANDglu_body_meta_demo.txt",
sep="\t", row.names = F, quote = F)
# Save the glu_3_males50s as a txt file.
write.table(glu_3_males50s, "eg_data/NHANES/Laboratory_data/QCtotalANDglu_body_meta_demo_males50s.txt",
sep="\t", row.names = F, quote = F)
# ========================================================================================
# Header 1 -- explain the purpose of this section.
# ========================================================================================
#
# ---------------------------------------------------------------------------------------------------------------
# Header 2 -- explain the purpose of this subsection.
glu_3_males50s <- read.table("eg_data/NHANES/Laboratory_data/QCtotalANDglu_body_meta_demo_males50s.txt",
sep="\t", header=T)
# ===============================================================================================================
# Prep for PCA
# ===============================================================================================================
# Perform PCA and plot the individuals. color code by GLU_index.
head(glu_3_males50s)
# Load the necessary functions
source("lib/prep_data_for_clustering.R")
source("lib/PCA.R")
source("lib/k-means.R")
# Define which columns to drop.
drops <- c("KCAL","GRMS", "MOIS", "NoOfItems")
# Take only the columns whose names are NOT in the drop vector.
aaa <- glu_3_males50s[ , !(names(glu_3_males50s) %in% drops)]
colnames(aaa)
dim(glu_3_males50s)
dim(aaa)
# ---------------------------------------------------------------------------------------------------------------
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Nutrients
SubsetColumns(data=input_data, start.col="PROT", end.col="P226")
# Define the input data to be used.
input_data <- glu_3_males50s
# ---------------------------------------------------------------------------------------------------------------
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Nutrients
SubsetColumns(data=input_data, start.col="PROT", end.col="P226")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variables if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
# original
head(subsetted_non0var, 1)
dim(subsetted_non0var)
setwd("~/GitHub/dietary_patterns/eg_data/NHANES/Laboratory_data/")
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"QCtotalANDglu_body_meta_demo_males50s_rv.txt",
sep="\t", row.names=F, quote=F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn = "QCtotalANDglu_body_meta_demo_males50s_corr_mat.txt")
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", row.names=F, quote=F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn = "QCtotalANDglu_body_meta_demo_males50s_Nut_corr_mat.txt")
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- read.table("QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x=pca_input, scale = TRUE)
# Specify the directory (folder) to save the results.
res_dir = "PCA_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix = "males50s_Nut"
PerformPCA(pca.data=pca_input, pca.result=scaled_pca, out.dir= res_dir, out.prefix= res_prefix,
input= "QCtotalANDglu_body_meta_demo_males50s.txt")
source("lib/PCA.R")
source("../../../lib/PCA.R")
source("../../../lib/k-means.R")
PerformPCA(pca.data=pca_input, pca.result=scaled_pca, out.dir= res_dir, out.prefix= res_prefix,
input= "QCtotalANDglu_body_meta_demo_males50s.txt")
View(PerformPCA)
PerformPCA(pca.data=pca_input, pca.result=scaled_pca, out.dir= res_dir, out.prefix= res_prefix)
# Combine the input (totals before processing) with all the variables and the PC results.
SaveInputAndPCs(input="QCtotalANDglu_body_meta_demo_males50s.txt", pca.results = scaled_pca,
out.dir= res_dir_nut_asis, out.prefix= res_prefix_nut_asis)
# Specify the directory (folder) to save the results.
res_dir_nut = "PCA_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Nut"
# Specify the directory (folder) to save the results.
res_dir_nut = "PCA_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Nut"
# Perform PCA and save the results in a specified folder (out.dir) and a prefix (out.prefix).
PerformPCA(pca.data=pca_input, pca.result=scaled_pca, out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Combine the input (totals before processing) with all the variables and the PC results.
# Input is your items/totals input file before any prep for clustering, from which you derived the input for the PCA.
SaveInputAndPCs(input="QCtotalANDglu_body_meta_demo_males50s.txt", pca.results = scaled_pca,
out.dir= res_dir_nut, out.prefix= res_prefix_nut)
