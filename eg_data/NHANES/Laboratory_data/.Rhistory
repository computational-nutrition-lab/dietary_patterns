# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank())
foodcat_PCA
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank())
scale_fill_manual( values= c("steelblue3", "yellow", "hotpink") ,
labels= c("Normal", "Prediabetic", "Diabetic") )
foodcat_PCA
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank())
scale_fill_manual( values= c("steelblue3", "yellow", "hotpink") ,
labels= c("Normal", "Prediabetic", "Diabetic") )
foodnut_PCA
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c( "hotpink", "steelblue3", "yellow") ,
labels= c("Diabetic", "Normal", "Prediabetic" ) )
foodnut_PCA
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- read.table("QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- read.table("../QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Load the input & PC info.
Nut_PCs <- read.table('PCA_Nut_males50s/males50s_Nut_PCs.txt', sep="\t", header=T)
# Load the necessary functions
source("../../../lib/prep_data_for_clustering.R")
setwd("~/GitHub/dietary_patterns/eg_data/NHANES/Laboratory_data/")
# Load the necessary functions
source("../../../lib/prep_data_for_clustering.R")
source("../../../lib/PCA.R")
source("../../../lib/k-means.R")
# ---------------------------------------------------------------------------------------------------------------
# Load the glu_3_males50s data.
glu_3_males50s <- read.table("QCtotalANDglu_body_meta_demo_males50s.txt",
sep="\t", header=T)
dim(glu_3_males50s)
# There should be 124 individuals (rows)
dim(glu_3_males50s)
# Define which columns to drop.
drops <- c("KCAL","GRMS", "MOIS", "NoOfItems")
# Take only the columns whose names are NOT in the drop vector.
aaa <- glu_3_males50s[ , !(names(glu_3_males50s) %in% drops)]
dim(glu_3_males50s)
dim(glu_3_males50s)
dim(aaa)
# Save it as glu_3_males50s.
glu_3_males50s <- aaa
# Define the input data to be used.
input_data <- glu_3_males50s
colnames(input_data)
# ---------------------------------------------------------------------------------------------------------------
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Nutrients
SubsetColumns(data=input_data, start.col="PROT", end.col="P226")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variable if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
dim( selected_variables)
# original
head(subsetted_non0var, 1)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", row.names=F, quote=F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn = "QCtotalANDglu_body_meta_demo_males50s_Nut_corr_mat.txt")
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- read.table("../QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- read.table("QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x= pca_input, scale= TRUE)
# Specify the prefix of filenames to be saved.
res_prefix_Nut = "males50s_Nut"
# Specify the directory (folder) to save the results.
res_dir_Nut = "PCA_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_Nut = "males50s_Nut"
# Perform PCA and save the results in a specified folder (out.dir) and a prefix (out.prefix).
PerformPCA(pca.data=pca_input, pca.result=scaled_pca,
out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Combine the input (totals before processing) with all the variables and the PC results.
# Input is your items/totals input file before any prep for clustering, from which you derived the input for the PCA.
SaveInputAndPCs(input="QCtotalANDglu_body_meta_demo_males50s.txt", pca.results = scaled_pca,
out.dir= res_dir_Nut, out.prefix= res_prefix_Nut)
# Load the input & PC info.
Nut_PCs <- read.table("PCA_Nut_males50s/males50s_Nut_PCs.txt", sep="\t", header=T)
# Change to a factor so that factors will be displayed in order.
Nut_PCs$GLU_index <- factor(Nut_PCs$GLU_index, levels= c("Norm", "Pred", "Diab"))
head(Nut_PCs)
dim(Nut_PCs)
ggplot(data=Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index)) +
theme_bw(base_size = 14)
ggplot(data=Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index, size=3)) +
theme_bw(base_size = 14)
ggplot(data=Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index, size=2)) +
theme_bw(base_size = 14)
ggplot(data=Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=2) +
theme_bw(base_size = 14)
ggplot(data=Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
ggplot(data= Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
ggplot(data= Nut_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c( "hotpink", "steelblue3", "yellow") ,
labels= c("Diabetic", "Normal", "Prediabetic" ) )
foodnut_PCA
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("steelblue3", "yellow",      "hotpink") ,
labels= c("Normal",     "Prediabetic", "Diabetic") )
foodnut_PCA
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("steelblue3", "yellow",      "hotpink")
)
foodnut_PCA
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("hotpink",   "steelblue3", "yellow"  ),
labels= c("Diabetic",  "Normal",     "Prediabetic") )
foodnut_PCA
ggsave("PCA_Nut_males50s/males50s_Nut_PCA_by_GLU_index_3.png", foodcat_PCA,
device="png", width=6.3, height=6)
ggplot(data= Nut_PCs, aes(x=PC2, y=PC3, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
ggplot(data= Nut_PCs, aes(x=PC3, y=PC4, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
# Use the autoplot function.
foodnut_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size = 3, alpha = 1, na.rm = T, shape = 21,  aes(fill= GLU_index)) +
theme_bw(base_size = 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("hotpink",   "steelblue3", "yellow"  ),
labels= c("Diabetic",  "Normal",     "Prediabetic") )
foodnut_PCA
ggsave("PCA_Nut_males50s/males50s_Nut_PCA_by_GLU_index.png", foodnut_PCA,
device="png", width=6.3, height=6)
ggsave("PCA_Nut_males50s/males50s_Nut_PCA_by_GLU_index.png", foodnut_PCA,
device="png", width=6.5, height=6)
ggsave("PCA_Nut_males50s/males50s_Nut_PCA_by_GLU_index.png", foodnut_PCA,
device="png", width=6.6, height=6)
# ---------------------------------------------------------------------------------------------------------------
# The columns specified as start.col, end.col, and all columns in between will be selected.
# food categories
SubsetColumns(data=input_data, start.col="F_CITMLB", end.col="A_DRINKS")
# Pick up only the columns with non-zero variance, in order to run PCA, cluster analysis etc.
# The removed columns will be shown if any.
KeepNonZeroVarColumns(data = subsetted)
# Check the columns (variables) remained.
colnames(subsetted_non0var)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Collapse variables by correlation: take only one variable if they are highly correlated.
cbc_res <- CollapseByCorrelation(x = subsetted_non0var,
min.cor = 0.75,
select.rep.fcn = 'mean', verbose = T)
# Filter out highly correlated variables from the original dataset.
selected_variables <- subsetted_non0var[, cbc_res$reps]
# Check to see the name of the original and filtered variables.
# Among the variables in the same group, the one with the highest variance is kept
#  (according to the explanation above.)
# filtered
head(selected_variables, 1)
dim(selected_variables)
dim(subsetted_non0var)
# ---------------------------------------------------------------------------------------------------------------
# Save the variables after removing correlated variables
write.table(selected_variables,
"QCtotalANDglu_body_meta_demo_males50s_Cat_rv.txt",
sep="\t", row.names= F, quote= F)
# ---------------------------------------------------------------------------------------------------------------
# Save the correlation matrix for record in the results folder.
# cc is the correlation matrix produced when variables are collapsed by correlation.
SaveCorrMatrix(x=cc,
out.fn = "QCtotalANDglu_body_meta_demo_males50s_Cat_corr_mat.txt")
# Your input data should be a data frame with variables with non-zero variance.
pca_input <- read.table("QCtotalANDglu_body_meta_demo_males50s_Cat_rv.txt",
sep="\t", header=T)
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Ensure your input file has the correct number of rows and columns.
dim(pca_input)
# Perform PCA with the subset data, scaled.
scaled_pca <- prcomp(x= pca_input, scale= TRUE)
# Specify the directory (folder) to save the results.
res_dir_Cat = "PCA_Cat_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_Cat = "males50s_Cat"
# Perform PCA and save the results in a specified folder (out.dir) and a prefix (out.prefix).
PerformPCA(pca.data=pca_input, pca.result=scaled_pca, out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Perform PCA and save the results in a specified folder (out.dir) and a prefix (out.prefix).
PerformPCA(pca.data=pca_input, pca.result=scaled_pca,
out.dir= res_dir_Cat, out.prefix= res_prefix_Cat)
# Combine the input (totals before processing) with all the variables and the PC results.
# Input is your items/totals input file before any prep for clustering, from which you derived the input for the PCA.
SaveInputAndPCs(input="QCtotalANDglu_body_meta_demo_males50s.txt", pca.results = scaled_pca,
out.dir= res_dir_Cat, out.prefix= res_prefix_Cat)
# Load the input & PC info.
Cat_PCs <- read.table('PCA_Cat_males50s/males50s_Cat_PCs.txt', sep="\t", header=T)
head(Cat_PCs)
dim(Cat_PCs)
ggplot(data=Cat_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index)) +
theme_bw(base_size = 14)
ggplot(data=Cat_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
# Use the autoplot function.
foodcat_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size= 3, alpha= 1, na.rm= T, shape= 21,  aes(fill=GLU_index)) +
theme_bw(base_size= 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("hotpink",  "steelblue3",  "yellow") ,
labels= c("Diabetic", "Normal",      "Prediabetic") )
foodcat_PCA
ggplot(data=Cat_PCs, aes(x=PC1, y=PC2, color= GLU_index)) +
geom_point(aes(fill=GLU_index), size=3) +
theme_bw(base_size = 14)
# Use the autoplot function.
foodcat_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size= 3, alpha= 1, na.rm= T, shape= 21,  aes(fill=GLU_index)) +
theme_bw(base_size= 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("hotpink",  "steelblue3",  "yellow") ,
labels= c("Diabetic", "Normal",      "Prediabetic") )
foodcat_PCA
ggsave("PCA_Cat_males50s/males50s_Cat_PCA_by_GLU_index.png", foodcat_PCA,
device="png", width=6.3, height=6)
# Use the autoplot function.
foodcat_PCA <- autoplot(scaled_pca, loadings=T, loadings.label=T, loadings.colour = 'grey50',  # loadings.label=T if want to see it
data = input_data,  size= 3 ) +
# coord_cartesian(xlim =c(-0.2, 0.2), ylim = c(-0.2, 0.25)) +
geom_point(size= 3, alpha= 1, na.rm= T, shape= 21,  aes(fill=GLU_index)) +
theme_bw(base_size= 12) + theme(aspect.ratio = 1) +
# xlim(-0.3, 0.2) + ylim(-0.3, 0.2) +
theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
scale_fill_manual( values= c("hotpink",  "steelblue3",  "yellow") ,
labels= c("Diabetic", "Normal",      "Prediabetic") )
foodcat_PCA
ggsave("PCA_Cat_males50s/males50s_Cat_PCA_by_GLU_index_109.png", foodcat_PCA,
device="png", width=10, height=9)
ggsave("PCA_Cat_males50s/males50s_Cat_PCA_by_GLU_index_109.png", foodcat_PCA,
device="png", width=8, height=7)
ggsave("PCA_Cat_males50s/males50s_Cat_PCA_by_GLU_index_109.png", foodcat_PCA,
device="png", width=7, height=6.5)
ggsave("PCA_Cat_males50s/males50s_Cat_PCA_by_GLU_index_7x6.5.png", foodcat_PCA,
device="png", width=7, height=6.5)
setwd("~/GitHub/dietary_patterns/eg_data/NHANES/Laboratory_data/")
# Load the necessary functions
source("../../../lib/prep_data_for_clustering.R")
source("../../../lib/PCA.R")
source("../../../lib/k-means.R")
# ---------------------------------------------------------------------------------------------------------------
# Load the glu_3_males50s data.
glu_3_males50s <- read.table("QCtotalANDglu_body_meta_demo_males50s.txt",
sep="\t", header=T)
# There should be 124 individuals (rows)
dim(glu_3_males50s)
# Define which columns to drop.
drops <- c("KCAL","GRMS", "MOIS", "NoOfItems")
# Take only the columns whose names are NOT in the drop vector.
aaa <- glu_3_males50s[ , !(names(glu_3_males50s) %in% drops)]
dim(glu_3_males50s)
dim(aaa)
# Save it as glu_3_males50s.
selected_variables <- aaa
# Check the column names (variables)
colnames(selected_variables)
# ---------------------------------------------------------------------------------------------------------------
# Load the glu_3_males50s data.
glu_3_males50s <- read.table("QCtotalANDglu_body_meta_demo_males50s.txt",
sep="\t", header=T)
# There should be 124 individuals (rows)
dim(glu_3_males50s)
# Define which columns to drop.
drops <- c("KCAL","GRMS", "MOIS", "NoOfItems")
# Take only the columns whose names are NOT in the drop vector.
aaa <- glu_3_males50s[ , !(names(glu_3_males50s) %in% drops)]
dim(glu_3_males50s)
dim(aaa)
# Define the input data to be used.
input_data <- aaa
colnames(input_data)
# ---------------------------------------------------------------------------------------------------------------
# The columns specified as start.col, end.col, and all columns in between will be selected.
# Nutrients
SubsetColumns(data=input_data, start.col="PROT", end.col="P226")
# ---------------------------------------------------------------------------------------------------------------
# Your input data should be a data frame with variables with non-zero variance.
kmeans_input <- read.table("QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Ensure your input file has the correct number of rows and columns.
dim(kmeans_input)
# Ensure your input file has the correct number of rows and columns.
dim(selected_variables)
# ---------------------------------------------------------------------------------------------------------------
# Your input data should be a data frame with variables with non-zero variance.
selected_variables <- read.table("QCtotalANDglu_body_meta_demo_males50s_Nut_rv.txt",
sep="\t", header=T)
# Ensure your input file has the correct number of rows and columns.
dim(selected_variables)
# Scale the variables and define it as an input for k-means analysis.
kmeans_input <- scale(selected_variables) # correlated variables removed.
# Set your ggplot2 theme.
require(ggplot2)
theme_set(theme_bw(base_size = 14))
# Set seed for consistent results.
set.seed(123)
# ---------------------------------------------------------------------------------------------------------------
# Use the elbow method to find the ideal K. K cannot be larger than the number of datapoints (rows) in input.
ElbowMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Silhouette method to find the ideal K. This uses the cluster and factoextra package.
silhouettechart <- factoextra::fviz_nbclust(kmeans_input, kmeans, method="silhouette")
silhouettechart
# Or if the factoextra package does not work for some reason, there is a way to only use the
# cluster package.
SilhouetteMethod(k.values = 2:15)
# Or if the factoextra package does not work for some reason, there is a way to only use the
# cluster package.
SilhouetteMethod(k.values = 2:15)
# Or if the factoextra package does not work for some reason, there is a way to only use the
# cluster package.
SilhouetteMethod(k.values = 2:15)
# Or if the factoextra package does not work for some reason, there is a way to only use the
# cluster package.
SilhouetteMethod(k.values = 2:15)
# Or if the factoextra package does not work for some reason, there is a way to only use the
# cluster package.
SilhouetteMethod(k.values = 2:15)
# ---------------------------------------------------------------------------------------------------------------
# Use the Gap statistic method to find the ideal K. The highest K is the optimum K.
GapMethod(k.values = 1:15)
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with one specified k.
oneKplot <- One_K(myK = 3)
source("../../../lib/k-means.R")
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with one specified k.
oneKplot <- One_K(myK = 3)
# ---------------------------------------------------------------------------------------------------------------
# Perform k-means analysis with one specified k.
oneKplot <- OneK(myK = 3)
# ---------------------------------------------------------------------------------------------------------------
res_dir_Cat <- 'k-means_Nut_males50s'
# Perform k-means analysis with one specified k.
oneKplot <- OneK(myK = 3, out.dir= res_dir_Cat, out.fn = "males50s_Nut_kmeans_K3")
oneKplot
oneKplot
# Perform k-means analysis with one specified k.
oneK <- OneK(myK = 3, out.dir= res_dir_Cat, out.fn = "males50s_Nut_kmeans_K3")
oneK
# Run elbow, silhouette, and gap methods to find an optimum K (number of clusters).
ChooseK(out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# ---------------------------------------------------------------------------------------------------------------
# Specify the directory (folder) to save the results.
res_dir_nut = "means_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Nut"
# Run elbow, silhouette, and gap methods to find an optimum K (number of clusters).
ChooseK(out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# ---------------------------------------------------------------------------------------------------------------
# Specify the directory (folder) to save the results.
res_dir_nut = "k-means_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Nut"
# Run elbow, silhouette, and gap methods to find an optimum K (number of clusters).
ChooseK(out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Try multiple Ks and print the biplots in one panel.
MultipleK(myKs = c(2,3,4), out.dir = res_dir_Nut, out.fn = "males50s_Nut_kmeans_K2-4")
# ---------------------------------------------------------------------------------------------------------------
# Specify the directory (folder) to save the results.
res_dir_nut = "k-means_Nut_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Nut"
# Run elbow, silhouette, and gap methods to find an optimum K (number of clusters).
ChooseK(out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Perform k-means analysis with one specified k.
oneK <- OneK(myK = 3, out.dir= res_dir_nut, out.fn = "males50s_Nut_kmeans_K3")
oneK
# Try multiple Ks and print the biplots in one panel.
MultipleK(myKs = c(2,3,4), out.dir = res_dir_nut, out.fn = "males50s_Nut_kmeans_K2-4")
source("../../../lib/ggplot2themes.R")
# Run elbow, silhouette, and gap methods to find an optimum K (number of clusters).
ChooseK(out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Perform k-means analysis with one specified k.
oneK <- OneK(myK = 3, out.dir= res_dir_nut, out.fn = "males50s_Nut_kmeans_K3")
oneK
# Try multiple Ks and print the biplots in one panel.
MultipleK(myKs = c(2,3,4), out.dir = res_dir_nut, out.fn = "males50s_Nut_kmeans_K2-4")
# ===============================================================================================================
# Prep for k-means with food categories.
# ===============================================================================================================
# Your input data should be a data frame with variables with non-zero variance.
selected_variables <- read.table("QCtotalANDglu_body_meta_demo_males50s_Cat_rv.txt",
sep="\t", header=T)
# Ensure your input file has the correct number of rows and columns.
dim(selected_variables)
# Scale the variables and define it as an input for k-means analysis.
kmeans_input <- scale(selected_variables) # correlated variables removed.
# Scale the variables and define it as an input for k-means analysis.
kmeans_input <- scale(selected_variables) # correlated variables removed.
# Set seed for consistent results.
set.seed(123)
# Specify the directory (folder) to save the results.
res_dir_nut = "k-means_Cat_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Cat"
# Specify the directory (folder) to save the results.
res_dir_nut = "k-means_Cat_males50s"
# Specify the prefix of filenames to be saved.
res_prefix_nut = "males50s_Cat"
# Run elbow, silhouette, and gap methods to find an optimum K (number of clusters).
ChooseK(out.dir= res_dir_nut, out.prefix= res_prefix_nut)
# Perform k-means analysis with one specified k. It will be saved as a PDF.
oneK <- OneK(myK = 3, out.dir= res_dir_nut, out.fn = "males50s_Cat_kmeans_K3")
# Try multiple Ks and print the biplots in one panel.
MultipleK(myKs= c(2,3,4,5), out.dir= res_dir_nut, out.fn= "males50s_Cat_kmeans_K2-5")
